<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>超越梦想</title>  
<META HTTP-EQUIV="Pragma" CONTENT="no-cache"> 
<META HTTP-EQUIV="Cache-Control" CONTENT="no-cache"> 
<META HTTP-EQUIV="Expires" CONTENT="0"> 
<meta content=" 应聘Java笔试时可能出现问题及其答案  Java 编程技术中汉字问题的分析及解决(从根源上解决)  JSTL简化JSP编码  阅读贪吃蛇源码  jsp文件操作 java 学习步骤 每个java初学者都应该搞懂的问题！ 创建用于 ASP.NET 的分页程序控件[MSDN]  初学者如何开发出一个高质量的J2EE系统  JSP页面连接数据库大全  博客 博客中国 博客动力 blog blogchina blogger 中国" name="description"> 
<meta name="keywords" content="超越梦想 应聘Java笔试时可能出现问题及其答案  Java 编程技术中汉字问题的分析及解决(从根源上解决)  JSTL简化JSP编码  阅读贪吃蛇源码  jsp文件操作 java 学习步骤 每个java初学者都应该搞懂的问题！ 创建用于 ASP.NET 的分页程序控件[MSDN]  初学者如何开发出一个高质量的J2EE系统  JSP页面连接数据库大全  博客 博客动力 blog blogchina blogger 中国 "> 
<link href="default.css" rel="stylesheet" type="text/css">
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="http://publishblog.bokee.com/jsp/rsd.jsp?blogID=413995&domain=youyou2005" />
<script language="javascript" type="text/javascript" src="http://blog.blogchina.com/jsp/js/img-auto-size.js"></script>
<script language="javascript" type="text/javascript" src="http://blog.blogchina.com/jsp/js/blog.js"></script>
<script language="javascript" type="text/javascript" src="http://blog.blogchina.com/jsp/js/newsChannel.js"></script>
<script type="text/javascript">
var calendarHover="calendarHover";
var classTemp;
d = new Date(); 
day = d.getDate();
d.setDate(1);
var tStr = "|6||6||14|";
var date = 14;
var month = 9;
var blogDomino = "youyou2005"; 

function updateHits(){
	var image = document.createElement("<img></img>");
	image.src = "http://counter.blogchina.com/counter/BlogServlet?blogid=413995";
	image.style.display='none'; 
	return true;
}

function checkFrm(){
document.getElementById('guestBookForm').submit();
}
</script>
</head>
<body>    
  <div id="container">
    <div id="header"><h1 class="title">超越梦想</h1></div>
	 <div id="leftFrm">	
	 <div id="operaTitle"></div>
	 <div id="myPhoto" class="operation"> 
		  <h4>关于作者</h4>		  
      <table width="100%" border="0" cellspacing="0" cellpadding="0">
        <tr> 
          <td>        
                      </td>
        </tr>         	
        <tr> 
          <td>
          用户名：youyou2005<br />
          笔名：youyou2005<br />
          地区：          		   
          		             		   </td>
        </tr>
      </table>
	 </div>
	 	
	   <div id="calendar" class="operation">
		  <h4>日历	　<script>document.write(d.getFullYear());</script>年<script>document.write(d.getMonth()+1);</script>月<script>document.write(day)</script>日</h4>	
          <table border="0" cellspacing="1" cellpadding="0" class="calendarBigBorder">
          <tr>
            <td class="calendarDaySun" onMouseover='{classTemp=this.className;this.className=calendarHover}' onMouseOut='this.className=classTemp'>日</td>
            <td class="calendarTd" onMouseover='{classTemp=this.className;this.className=calendarHover}' onMouseOut='this.className=classTemp'>一</td>
            <td class="calendarTd" onMouseover='{classTemp=this.className;this.className=calendarHover}' onMouseOut='this.className=classTemp'>二</td>
            <td class="calendarTd" onMouseover='{classTemp=this.className;this.className=calendarHover}' onMouseOut='this.className=classTemp'>三</td>
            <td class="calendarTd" onMouseover='{classTemp=this.className;this.className=calendarHover}' onMouseOut='this.className=classTemp'>四</td>
            <td class="calendarTd" onMouseover='{classTemp=this.className;this.className=calendarHover}' onMouseOut='this.className=classTemp'>五</td>
            <td class="calendarDaySat" onMouseover='{classTemp=this.className;this.className=calendarHover}' onMouseOut='this.className=classTemp'>六</td>
         </tr>
        <script>
	        for(j = 0; j < 6; j++){
	            document.write("<tr>");
	        	for(i = 1; i < 8; i++){
	        		document.write("<td ");
	        		if(tStr.indexOf("|"+d.getDate()+"|")!=-1&&(d.getMonth()+1)==month){ 
	        		document.write("class=\"calendarLink\""); 
	        		}
	        		else{
	        			if(date == d.getDate()) document.write(" class=\"calendarNow\"");
	        			else if(i == 1) document.write(" class=\"calendarDaySat\""); 
	        			else if(i == 7) document.write(" class=\"calendarDaySat\"");
	        			else document.write(" class=\"calendarTd\"");
	        		}
	        		document.write("onMouseover='{classTemp=this.className;this.className=calendarHover}' onMouseOut='this.className=classTemp'>");
	        		if(d.getDay()==(i-1)&&(d.getMonth()+1)==month){
	        		 if(tStr.indexOf("|"+d.getDate()+"|")!=-1&&(d.getMonth()+1)==month){
	        		 	aNameStr = d.getYear()+""+(d.getMonth()+1)+""+d.getDate();
	        		 	document.write("<a href='catalog_"+d.getFullYear()+".html#time"+aNameStr+"'>"+d.getDate()+"</a>");
	        		 }
	        		 else document.write(d.getDate()+"");	        		   		
	        		 tempD = d.getDate();        		
	        		 d.setDate(tempD+1);
	        		}else document.write("　");	      
	        		document.write("</td>");
	        	} 
	        	document.write("</tr>");
	        }
        </script>       
      </table>
    </div> 
	<div id="loginFrm" class="operation">
		  <h4>快速登录</h4> 
      <table width="100%" border="0" cellspacing="4" cellpadding="0">		  
	  <form method="post" action="http://publishblog.blogchina.com/login.b"> 
        <tr> 
          <td align="right" class="tdText" nowrap="true">+ 用户名：</td>
          <td><input name="user.userNameFUI" type="text" class="inputStyle" id="userName" size="20" maxlength="51"></td>
        </tr>
        <tr> 
          <td align="right" class="tdText" nowrap="true">+ 密　码：</td>
          <td><input name="user.password" type="password" class="inputStyle" id="passWord" size="20" maxlength="51"></td>
        </tr>
        <tr align="center"> 
          <td nowrap="true" colspan="2"> 
            <input type="submit" class="buttonStyle" style="width:27px" value="登录" style="cursor:hand">            
            <input type="button" class="buttonStyle" style="width:50px" value="直接登录" onClick="javascript:{window.location.href='http://publishblog.blogchina.com/control/main.b';}" style="cursor:hand"> 
            <input type="button" class="buttonStyle" style="width:27px" value="注册" onClick="javascript:{window.location.href='http://publishblog.blogchina.com/reg.b';}" style="cursor:hand">
            <input type="button" class="buttonStyle" style="width:50px" value="快速撰写" onClick="window.open('http://publishblog.blogchina.com/simplePost.b','写新文章','width=705,heigth=700,scrollbars=yes');">
             </td> 
        </tr>
        <tr>
        <td colspan="2" align="center"><br/>
        <a href="javascript:{window.location.href='http://blogmark.blogchina.com/API.k?method=showKeyByName&userName='+encodeURI('youyou2005');};">我的博采</a>　<a href="http://forum.blogchina.com/">我的论坛</a>　<a href="http://rss.blogchina.com/user.htm">我的RSS</a>
        </td>
        </tr>
      </form>
      </table>
      </div>
	  <div id="newWeblog" class="operation">
		  <h4>最新文章</h4>
		  <ul>		  
		  		  <li class="weblog"><a href="2916217.html">
		  		  应聘Java笔试时可能出现问题及其答案 </a></li>
		  		  		  <li class="weblog"><a href="2836055.html">
		  		  Java 编程技术中汉字问题的分析及解决(从根源上解决) </a></li>
		  		  		  <li class="weblog"><a href="2836029.html">
		  		  JSTL简化JSP编码 </a></li>
		  		  		  <li class="weblog"><a href="2617904.html">
		  		  阅读贪吃蛇源码 </a></li>
		  		  		  <li class="weblog"><a href="2567578.html">
		  		  jsp文件操作</a></li>
		  		  		  <li class="weblog"><a href="2490191.html">
		  		  java 学习步骤</a></li>
		  		  		  <li class="weblog"><a href="2395593.html">
		  		  每个java初学者都应该搞懂的问题！</a></li>
		  		  		  <li class="weblog"><a href="2279153.html">
		  		  创建用于 ASP.NET 的分页程序控件[MSDN] </a></li>
		  		  		  <li class="weblog"><a href="2243654.html">
		  		  初学者如何开发出一个高质量的J2EE系统 </a></li>
		  		  		  <li class="weblog"><a href="2207126.html">
		  		  JSP页面连接数据库大全</a></li>
		  		  		 </ul>
		</div>
	  <div id="blogIndex" class="operation">
		  <h4>文章索引</h4>
		  <ul>
		  		  <li class="weblog"><a href="catalog_2005.html">2005年索引</a></li>
		  		 </ul>
	  </div>	
		 <form method="post" action="http://publishblog.blogchina.com/blog/postNote.b" name="guestBookForm" id="guestBookForm">
		 <input type="hidden" name="blogID" value="413995"/>
		 <input type="hidden" name="blogDomino" value="youyou2005"/>
		<div id="guestBook" class="operation">
		  <h4>在线留言</h4>
		  <div class="guestBook"><ul>
		   <script type="text/javascript" src="notes.js"></script>	
		 </ul></div>
		<script>
		if(getCookie('userID') == null) document.write('<h6 class="name">昵　称：</h6> <input name="note.authorNameFUI" type="text" class="guestbookName" id="userName" size="10" maxlength="16"  value="请输入用户名" onblur="if(this.value==\'\')this.value=\'请输入用户名\'" onfocus="if(this.value==\'请输入用户名\')this.value=\'\'">');
		else document.write('　　　　　　');
		</script>
		   <input name="Submit" type="button" class="buttonStyle" value="发表" onClick="checkFrm()">  		  
		  		  <textarea name="note.noteContentFUI" class="guestbookInput"></textarea><br/>  	  
		  <br/>
		</div></form>
				<div id="remark" class="operation">
		  <h4>最新评论</h4>
		  <ul>
		  		  </ul>
		</div>	
								<div id="otherFrm" class="operation">
				  <h4>访问统计：<script language="JavaScript" src="http://counter.blogchina.com/BlogServlet?blogid=413995"></script><br/>
				  文章个数:16<br/>
				  评论个数:0<br/>
				  留言条数:0</h4>
		  <div class="logoFrm">
		    <table height="31" border="0" cellpadding="0" cellspacing="0">
          <tr>
            <td rowspan="3" align="right"><a href="http://www.bokee.com/"><img border="0" src="http://www.blogchina.com/new/about/linkimg/blogchina88-31.gif"></a></td>
            <td align="left"><a href="http://publishblog.blogchina.com/blog/addFriendBlog.b?blogID=413995&blogDomino=youyou2005"><img border="0" src="http://blog.blogchina.com/template/common/img/addfriend.jpg"></a></td>
          </tr>
          <tr>
            <td align="left"><a href="http://publishblog.blogchina.com/blog/addFriend.b?userID=413486&blogDomino=youyou2005"><img border="0" src="http://blog.blogchina.com/template/common/img/adduse.jpg"></a></td>
          </tr>
        </table> 
		  </div>	<br/>        
		  <a href="atom.xml"><img class="rss" src="http://blog.blogchina.com/template/common/img/xml.gif"></a>
		  <a href="rss1.xml"><img class="rss" src="http://blog.blogchina.com/template/common/img/rss1.gif"></a>
		  <a href="rss2.xml"><img class="rss" src="http://blog.blogchina.com/template/common/img/rss2.gif"></a> 	<br/>
		  <a href="http://www.blogdriver.com/">Powered by BlogDriver 2.1</a>
		</div>
		<script type="text/javascript" src="extend1.js"></script> 
	 </div>
    <div id="rightFrm">
	   <div id="mybolg">
		  <div id="blogImg"><h4 class="textBlog"></h4></div>
		  <div id="blogContent">
		     <h3>超越梦想</h3>
			  　<p class="content"></p>
		  </div>
		</div>
		<div id="diary">
		     <h4 class="textDiary">文章 </h4>
		     <div id="category"><a href="catalog_2005.html">总目录</a>| 
		    		     <a href="catalog_2005.html#category4" title="">科技前沿</a> | 
		    		     <a href="catalog_2005.html#category5" title="">人生之路</a> | 
		    		     <a href="catalog_2005.html#category6" title="">技术文章</a> | 
		    		     <a href="catalog_2005.html#category7" title="">问题解答</a> | 
		    		     </div>
		    
						
			  <div class="entity">
			    <h5 class="diaryTitle"><img src="http://blog.blogchina.com/template/common/img/array.gif"
 onclick="{if((document.getElementById('diary2916217')).style.display=='none') {(document.getElementById('diary2916217')).style.display='block'; this.src='http://blog.blogchina.com/template/common/img/array.gif'} else {(document.getElementById('diary2916217')).style.display='none'; this.src='http://blog.blogchina.com/template/common/img/array_2.gif'}}" class="imgShow">
			    <a href="2916217.html">
			    应聘Java笔试时可能出现问题及其答案 </a>
			    			    </h5>
				<div id="diary2916217" style="display:block
				" class="diaryContent"> 
				      				      Java基础方面: <br /><br />1、作用域public,private,protected,以及不写时的区别 <br />答：区别如下： <br />作用域 当前类 同一package 子孙类 其他package <br />public √ √ √ √ <br />protected √ √ √ × <br />friendly √ √ × × <br />private √ × × × <br />不写时默认为friendly <br /><br />2、ArrayList和Vector的区别,HashMap和Hashtable的区别 <br />答：就ArrayList与Vector主要从二方面来说. <br />一.同步性:Vector是线程安全的，也就是说是同步的，而ArrayList是线程序不安全的，不是同步的 <br />二.数据增长:当需要增长时,Vector默认增长为原来一培，而ArrayList却是原来的一半 <br />就HashMap与HashTable主要从三方面来说。 <br />一.历史原因:Hashtable是基于陈旧的Dictionary类的，HashMap是Java 1.2引进的Map接口的一个实现 <br />二.同步性:Hashtable是线程安全的，也就是说是同步的，而HashMap是线程序不安全的，不是同步的 <br />三.值：只有HashMap可以让你将空值作为一个表的条目的key或value <br /><br />3、char型变量中能不能存贮一个中文汉字?为什么? <br />答：是能够定义成为一个中文的，因为java中以unicode编码，一个char占16个字节，所以放一个中文是没问题的 <br /><br />4、多线程有几种实现方法,都是什么?同步有几种实现方法,都是什么? <br />答：多线程有两种实现方法，分别是继承Thread类与实现Runnable接口 <br />同步的实现方面有两种，分别是synchronized,wait与notify <br /><br />5、继承时候类的执行顺序问题,一般都是选择题,问你将会打印出什么? <br />答:父类： <br />package test; <br />public class FatherClass <br />{ <br />public FatherClass() <br />{ <br />System.out.println(&quot;FatherClass Create&quot;); <br />} <br />} <br />子类: <br />package test; <br />import test.FatherClass; <br />public class ChildClass extends FatherClass <br />{ <br />public ChildClass() <br />{ <br />System.out.println(&quot;ChildClass Create&quot;); <br />} <br />public static void main(String[] args) <br />{ <br />FatherClass fc = new FatherClass(); <br />ChildClass cc = new ChildClass(); <br />} <br />} <br />输出结果： <br />C:\&gt;java test.ChildClass <br />FatherClass Create <br />FatherClass Create <br />ChildClass Create <br /><br />6、内部类的实现方式? <br />答：示例代码如下： <br />package test; <br />public class OuterClass <br />{ <br />private class InterClass <br />{ <br />public InterClass() <br />{ <br />System.out.println(&quot;InterClass Create&quot;); <br />} <br />} <br />public OuterClass() <br />{ <br />InterClass ic = new InterClass(); <br />System.out.println(&quot;OuterClass Create&quot;); <br />} <br />public static void main(String[] args) <br />{ <br />OuterClass oc = new OuterClass(); <br />} <br />} <br />输出结果: <br />C:\&gt;java test/OuterClass <br />InterClass Create <br />OuterClass Create <br />再一个例题： <br />public class OuterClass { <br />private double d1 = 1.0; <br />//insert code here <br />} <br />You need to insert an inner class declaration at line 3. Which two inner class declarations are <br /><br />valid?(Choose two.) <br />A. class InnerOne{ <br />public static double methoda() {return d1;} <br />} <br />B. public class InnerOne{ <br />static double methoda() {return d1;} <br />} <br />C. private class InnerOne{ <br />double methoda() {return d1;} <br />} <br />D. static class InnerOne{ <br />protected double methoda() {return d1;} <br />} <br />E. abstract class InnerOne{ <br />public abstract double methoda(); <br />} <br />说明如下： <br />一.静态内部类可以有静态成员，而非静态内部类则不能有静态成员。 故 A、B 错 <br />二.静态内部类的非静态成员可以访问外部类的静态变量，而不可访问外部类的非静态变量；return d1 出错。 <br /><br />故 D 错 <br />三.非静态内部类的非静态成员可以访问外部类的非静态变量。 故 C 正确 <br />四.答案为C、E <br /><br />7、垃圾回收机制,如何优化程序? <br />希望大家补上，谢谢 <br /><br />8、float型float f=3.4是否正确? <br />答:不正确。精度不准确,应该用强制类型转换，如下所示：float f=(float)3.4 <br /><br />9、介绍JAVA中的Collection FrameWork(包括如何写自己的数据结构)? <br />答：Collection FrameWork如下： <br />Collection <br />├List <br />│├LinkedList <br />│├ArrayList <br />│└Vector <br />│　└Stack <br />└Set <br />Map <br />├Hashtable <br />├HashMap <br />└WeakHashMap <br />Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素（Elements） <br />Map提供key到value的映射 <br /><br />10、Java中异常处理机制，事件机制？ <br /><br />11、JAVA中的多形与继承？ <br />希望大家补上，谢谢 <br /><br />12、抽象类与接口？ <br />答：抽象类与接口都用于抽象，但是抽象类(JAVA中)可以有自己的部分实现，而接口则完全是一个标识(同时有多重继承的功能)。 <br /><br />13、Java 的通信编程，编程题(或问答)，用JAVA SOCKET编程，读服务器几个字符，再写入本地显示？ <br />答:Server端程序: <br />package test; <br />import java.net.*; <br />import java.io.*; <br /><br />public class Server <br />{ <br />private ServerSocket ss; <br />private Socket socket; <br />private BufferedReader in; <br />private PrintWriter out; <br />public Server() <br />{ <br />try <br />{ <br />ss=new ServerSocket(10000); <br />while(true) <br />{ <br />socket = ss.accept(); <br />String RemoteIP = socket.getInetAddress().getHostAddress(); <br />String RemotePort = &quot;:&quot;+socket.getLocalPort(); <br />System.out.println(&quot;A client come in!IP:&quot;+RemoteIP+RemotePort); <br />in = new BufferedReader(new <br /><br />InputStreamReader(socket.getInputStream())); <br />String line = in.readLine(); <br />System.out.println(&quot;Cleint send is :&quot; + line); <br />out = new PrintWriter(socket.getOutputStream(),true); <br />out.println(&quot;Your Message Received!&quot;); <br />out.close(); <br />in.close(); <br />socket.close(); <br />} <br />}catch (IOException e) <br />{ <br />out.println(&quot;wrong&quot;); <br />} <br />} <br />public static void main(String[] args) <br />{ <br />new Server(); <br />} <br />}; <br />Client端程序: <br />package test; <br />import java.io.*; <br />import java.net.*; <br /><br />public class Client <br />{ <br />Socket socket; <br />BufferedReader in; <br />PrintWriter out; <br />public Client() <br />{ <br />try <br />{ <br />System.out.println(&quot;Try to Connect to 127.0.0.1:10000&quot;); <br />socket = new Socket(&quot;127.0.0.1&quot;,10000); <br />System.out.println(&quot;The Server Connected!&quot;); <br />System.out.println(&quot;Please enter some Character:&quot;); <br />BufferedReader line = new BufferedReader(new <br /><br />InputStreamReader(System.in)); <br />out = new PrintWriter(socket.getOutputStream(),true); <br />out.println(line.readLine()); <br />in = new BufferedReader(new InputStreamReader(socket.getInputStream())); <br />System.out.println(in.readLine()); <br />out.close(); <br />in.close(); <br />socket.close(); <br />}catch(IOException e) <br />{ <br />out.println(&quot;Wrong&quot;); <br />} <br />} <br />public static void main(String[] args) <br />{ <br />new Client(); <br />} <br />}; <br /><br />14、用JAVA实现一种排序，JAVA类实现序列化的方法(二种)？ 如在COLLECTION框架中，实现比较要实现什么样的接口？ <br />答:用插入法进行排序代码如下 <br />package test; <br />import java.util.*; <br />class InsertSort <br />{ <br />ArrayList al; <br />public InsertSort(int num,int mod) <br />{ <br />al = new ArrayList(num); <br />Random rand = new Random(); <br />System.out.println(&quot;The ArrayList Sort Before:&quot;); <br />for (int i=0;i&lt;num ;i++ ) <br />{ <br />al.add(new Integer(Math.abs(rand.nextInt()) % mod + 1)); <br />System.out.println(&quot;al[&quot;+i+&quot;]=&quot;+al.get(i)); <br />} <br />} <br />public void SortIt() <br />{ <br />Integer tempInt; <br />int MaxSize=1; <br />for(int i=1;i&lt;al.size();i++) <br />{ <br />tempInt = (Integer)al.remove(i); <br />if(tempInt.intValue()&gt;=((Integer)al.get(MaxSize-1)).intValue()) <br />{ <br />al.add(MaxSize,tempInt); <br />MaxSize++; <br />System.out.println(al.toString()); <br />} else { <br />for (int j=0;j&lt;MaxSize ;j++ ) <br />{ <br />if <br /><br />(((Integer)al.get(j)).intValue()&gt;=tempInt.intValue()) <br />{ <br />al.add(j,tempInt); <br />MaxSize++; <br />System.out.println(al.toString()); <br />break; <br />} <br />} <br />} <br />} <br />System.out.println(&quot;The ArrayList Sort After:&quot;); <br />for(int i=0;i&lt;al.size();i++) <br />{ <br />System.out.println(&quot;al[&quot;+i+&quot;]=&quot;+al.get(i)); <br />} <br />} <br />public static void main(String[] args) <br />{ <br />InsertSort is = new InsertSort(10,100); <br />is.SortIt(); <br />} <br />} <br />JAVA类实现序例化的方法是实现java.io.Serializable接口 <br />Collection框架中实现比较要实现Comparable 接口和 Comparator 接口 <br /><br />15、编程：编写一个截取字符串的函数，输入为一个字符串和字节数，输出为按字节截取的字符串。 但是要保证汉字不被截半个，如“我ABC”4，应该截为“我AB”，输入“我ABC汉DEF”，6，应该输出为“我ABC”而不是“我ABC+汉的半个”。 <br />答：代码如下： <br />package test; <br /><br />class SplitString <br />{ <br />String SplitStr; <br />int SplitByte; <br />public SplitString(String str,int bytes) <br />{ <br />SplitStr=str; <br />SplitByte=bytes; <br />System.out.println(&quot;The String is:&acute;&quot;+SplitStr+&quot;&acute;;SplitBytes=&quot;+SplitByte); <br />} <br />public void SplitIt() <br />{ <br />int loopCount; <br /><br /><br />loopCount=(SplitStr.length()%SplitByte==0)?(SplitStr.length()/SplitByte):(SplitStr.length()/Split <br /><br />Byte+1); <br />System.out.println(&quot;Will Split into &quot;+loopCount); <br />for (int i=1;i&lt;=loopCount ;i++ ) <br />{ <br />if (i==loopCount){ <br /><br /><br />System.out.println(SplitStr.substring((i-1)*SplitByte,SplitStr.length())); <br />} else { <br /><br /><br />System.out.println(SplitStr.substring((i-1)*SplitByte,(i*SplitByte))); <br />} <br />} <br />} <br />public static void main(String[] args) <br />{ <br />SplitString ss = new SplitString(&quot;test中dd文dsaf中男大3443n中国43中国人 <br /><br />0ewldfls=103&quot;,4); <br />ss.SplitIt(); <br />} <br />} <br /><br />16、JAVA多线程编程。 用JAVA写一个多线程程序，如写四个线程，二个加1，二个对一个变量减一，输出。 <br />希望大家补上，谢谢 <br /><br />17、STRING与STRINGBUFFER的区别。 <br />答：STRING的长度是不可变的，STRINGBUFFER的长度是可变的。如果你对字符串中的内容经常进行操作，特别是内容要修改时，那么使用StringBuffer，如果最后需要String，那么使用StringBuffer的toString()方法 <br /><br />Jsp方面 <br /><br />1、jsp有哪些内置对象?作用分别是什么? <br />答:JSP共有以下9种基本内置组件（可与ASP的6种内部组件相对应）： <br />　request 用户端请求，此请求会包含来自GET/POST请求的参数 <br />response 网页传回用户端的回应 <br />pageContext 网页的属性是在这里管理 <br />session 与请求有关的会话期 <br />application servlet 正在执行的内容 <br />out 用来传送回应的输出 <br />config servlet的构架部件 <br />page JSP网页本身 <br />exception 针对错误网页，未捕捉的例外 <br /><br />2、jsp有哪些动作?作用分别是什么? <br />答:JSP共有以下6种基本动作 <br />jsp:include：在页面被请求的时候引入一个文件。 <br />jsp:useBean：寻找或者实例化一个JavaBean。 <br />jsp:setProperty：设置JavaBean的属性。 <br />jsp:getProperty：输出某个JavaBean的属性。 <br />jsp:forward：把请求转到一个新的页面。 <br />jsp:plugin：根据浏览器类型为Java插件生成OBJECT或EMBED标记 <br /><br />3、JSP中动态INCLUDE与静态INCLUDE的区别？ <br />答：动态INCLUDE用jsp:include动作实现 <br />&lt;jsp:include page=&quot;included.jsp&quot; flush=&quot;true&quot; /&gt;它总是会检查所含文件中的变化，适合用于包含动态页面，并且可以带参数 <br />静态INCLUDE用include伪码实现,定不会检查所含文件的变化，适用于包含静态页面 <br />&lt;%@ include file=&quot;included.htm&quot; %&gt; <br /><br />4、两种跳转方式分别是什么?有什么区别? <br />答：有两种，分别为： <br />&lt;jsp:include page=&quot;included.jsp&quot; flush=&quot;true&quot;&gt; <br />&lt;jsp:forward page= &quot;nextpage.jsp&quot;/&gt; <br />前者页面不会转向include所指的页面，只是显示该页的结果，主页面还是原来的页面。执行完后还会回来，相当于函数调用。并且可以带参数.后者完全转向新页面，不会再回来。相当于go to 语句。 <br /><br />Servlet方面 <br /><br />1、说一说Servlet的生命周期? <br />答:servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。 <br /><br />2、Servlet版本间(忘了问的是哪两个版本了)的不同? <br />希望大家补上，谢谢 <br /><br />3、JAVA SERVLET API中forward() 与redirect()的区别？ <br />答:前者仅是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；后者则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的地址栏中可以看到跳转后的链接地址。所以，前者更加高效，在前者可以满足需要时，尽量使用forward()方法，并且，这样也有助于隐藏实际的链接。在有些情况下，比如，需要跳转到一个其它服务器上的资源，则必须使用sendRedirect()方法。 <br /><br />4、Servlet的基本架构 <br />public class ServletName extends HttpServlet { <br />public void doPost(HttpServletRequest request, HttpServletResponse response) throws <br />ServletException, IOException { <br />} <br />public void doGet(HttpServletRequest request, HttpServletResponse response) throws <br />ServletException, IOException { <br />} <br />} <br /><br />Jdbc、Jdo方面 <br /><br />1、可能会让你写一段Jdbc连Oracle的程序,并实现数据查询. <br />答:程序如下： <br />package hello.ant; <br />import java.sql.*; <br />public class jdbc <br />{ <br />String dbUrl=&quot;jdbc:oracle:thin:@127.0.0.1:1521:orcl&quot;; <br />String theUser=&quot;admin&quot;; <br />String thePw=&quot;manager&quot;; <br />Connection c=null; <br />Statement conn; <br />ResultSet rs=null; <br />public jdbc() <br />{ <br />try{ <br />Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;).newInstance(); <br />c = DriverManager.getConnection(dbUrl,theUser,thePw); <br />conn=c.createStatement(); <br />}catch(Exception e){ <br />e.printStackTrace(); <br />} <br />} <br />public boolean executeUpdate(String sql) <br />{ <br />try <br />{ <br />conn.executeUpdate(sql); <br />return true; <br />} <br />catch (SQLException e) <br />{ <br />e.printStackTrace(); <br />return false; <br />} <br />} <br />public ResultSet executeQuery(String sql) <br />{ <br />rs=null; <br />try <br />{ <br />rs=conn.executeQuery(sql); <br />} <br />catch (SQLException e) <br />{ <br />e.printStackTrace(); <br />} <br />return rs; <br />} <br />public void close() <br />{ <br />try <br />{ <br />conn.close(); <br />c.close(); <br />} <br />catch (Exception e) <br />{ <br />e.printStackTrace(); <br />} <br />} <br />public static void main(String[] args) <br />{ <br />ResultSet rs; <br />jdbc conn = new jdbc(); <br />rs=conn.executeQuery(&quot;select * from test&quot;); <br />try{ <br />while (rs.next()) <br />{ <br />System.out.println(rs.getString(&quot;id&quot;)); <br />System.out.println(rs.getString(&quot;name&quot;)); <br />} <br />}catch(Exception e) <br />{ <br />e.printStackTrace(); <br />} <br />} <br />} <br /><br />2、Class.forName的作用?为什么要用? <br />答：调用该访问返回一个以字符串指定类名的类的对象。 <br /><br />3、Jdo是什么? <br />答:JDO是Java对象持久化的新的规范，为java data object的简称,也是一个用于存取某种数据仓库中的对象的标准化API。JDO提供了透明的对象存储，因此对开发人员来说，存储数据对象完全不需要额外的代码（如JDBC API的使用）。这些繁琐的例行工作已经转移到JDO产品提供商身上，使开发人员解脱出来，从而集中时间和精力在业务逻辑上。另外，JDO很灵活，因为它可以在任何数据底层上运行。JDBC只是面向关系数据库（RDBMS)JDO更通用，提供到任何数据底层的存储功能，比如关系数据库、文件、XML以及对象数据库（ODBMS）等等，使得应用可移植性更强。 <br /><br />4、在ORACLE大数据量下的分页解决方法。一般用截取ID方法，还有是三层嵌套方法。 <br />答:一种分页方法 <br />&lt;% <br />int i=1; <br />int numPages=14; <br />String pages = request.getParameter(&quot;page&quot;) ; <br />int currentPage = 1; <br />currentPage=(pages==null)?(1):{Integer.parseInt(pages)} <br />sql = &quot;select count(*) from tables&quot;; <br />ResultSet rs = DBLink.executeQuery(sql) ; <br />while(rs.next()) i = rs.getInt(1) ; <br />int intPageCount=1; <br />intPageCount=(i%numPages==0)?(i/numPages):(i/numPages+1); <br />int nextPage ; <br />int upPage; <br />nextPage = currentPage+1; <br />if (nextPage&gt;=intPageCount) nextPage=intPageCount; <br />upPage = currentPage-1; <br />if (upPage&lt;=1) upPage=1; <br />rs.close(); <br />sql=&quot;select * from tables&quot;; <br />rs=DBLink.executeQuery(sql); <br />i=0; <br />while((i&lt;numPages*(currentPage-1))&amp;&amp;rs.next()){i++;} <br />%&gt; <br />//输出内容 <br />//输出翻页连接 <br />合计:&lt;%=currentPage%&gt;/&lt;%=intPageCount%&gt;&lt;a href=&quot;List.jsp?page=1&quot;&gt;第一页&lt;/a&gt;&lt;a <br /><br />href=&quot;List.jsp?page=&lt;%=upPage%&gt;&quot;&gt;上一页&lt;/a&gt; <br />&lt;% <br />for(int j=1;j&lt;=intPageCount;j++){ <br />if(currentPage!=j){ <br />%&gt; <br />&lt;a href=&quot;list.jsp?page=&lt;%=j%&gt;&quot;&gt;[&lt;%=j%&gt;]&lt;/a&gt; <br />&lt;% <br />}else{ <br />out.println(j); <br />} <br />} <br />%&gt; <br />&lt;a href=&quot;List.jsp?page=&lt;%=nextPage%&gt;&quot;&gt;下一页&lt;/a&gt;&lt;a href=&quot;List.jsp?page=&lt;%=intPageCount%&gt;&quot;&gt;最后页 <br /><br />&lt;/a&gt; <br /><br /><br />Xml方面 <br /><br />1、xml有哪些解析技术?区别是什么? <br />答:有DOM,SAX,STAX等 <br />DOM:处理大型文件时其性能下降的非常厉害。这个问题是由DOM的树结构所造成的，这种结构占用的内存较多，而且DOM必须在解析文件之前把整个文档装入内存,适合对XML的随机访问SAX:不现于DOM,SAX是事件驱动型的XML解析方式。它顺序读取XML文件，不需要一次全部装载整个文件。当遇到像文件开头，文档结束，或者标签开头与标签结束时，它会触发一个事件，用户通过在其回调事件中写入处理代码来处理XML文件，适合对XML的顺序访问 <br />STAX:Streaming API for XML (StAX) <br /><br />2、你在项目中用到了xml技术的哪些方面?如何实现的? <br />答:用到了数据存贮，信息配置两方面。在做数据交换平台时，将不能数据源的数据组装成XML文件，然后将XML文件压缩打包加密后通过网络传送给接收者，接收解密与解压缩后再同XML文件中还原相关信息进行处理。在做软件配置时，利用XML可以很方便的进行，软件的各种配置参数都存贮在XML文件中。 <br /><br />3、用jdom解析xml文件时如何解决中文问题?如何解析? <br />答:看如下代码,用编码方式加以解决 <br />package test; <br />import java.io.*; <br />public class DOMTest <br />{ <br />private String inFile = &quot;c:\\people.xml&quot;; <br />private String outFile = &quot;c:\\people.xml&quot;; <br />public static void main(String args[]) <br />{ <br />new DOMTest(); <br />} <br />public DOMTest() <br />{ <br />try <br />{ <br />javax.xml.parsers.DocumentBuilder builder = <br /><br /><br />javax.xml.parsers.DocumentBuilderFactory.newInstance().newDocumentBuilder(); <br />org.w3c.dom.Document doc = builder.newDocument(); <br />org.w3c.dom.Element root = doc.createElement(&quot;老师&quot;); <br />org.w3c.dom.Element wang = doc.createElement(&quot;王&quot;); <br />org.w3c.dom.Element liu = doc.createElement(&quot;刘&quot;); <br />wang.appendChild(doc.createTextNode(&quot;我是王老师&quot;)); <br />root.appendChild(wang); <br />doc.appendChild(root); <br />javax.xml.transform.Transformer transformer = <br />javax.xml.transform.TransformerFactory.newInstance().newTransformer(); <br />transformer.setOutputProperty(javax.xml.transform.OutputKeys.ENCODING, &quot;gb2312&quot;); <br />transformer.setOutputProperty(javax.xml.transform.OutputKeys.INDENT, &quot;yes&quot;); <br /><br /><br />transformer.transform(new javax.xml.transform.dom.DOMSource(doc), <br />new <br /><br />javax.xml.transform.stream.StreamResult(outFile)); <br />} <br />catch (Exception e) <br />{ <br />System.out.println (e.getMessage()); <br />} <br />} <br />} <br /><br />4、编程用JAVA解析XML的方式. <br />答:用SAX方式解析XML，XML文件如下： <br />&lt;?xml version=&quot;1.0&quot; encoding=&quot;gb2312&quot;?&gt; <br />&lt;person&gt; <br />&lt;name&gt;王小明&lt;/name&gt; <br />&lt;college&gt;信息学院&lt;/college&gt; <br />&lt;telephone&gt;6258113&lt;/telephone&gt; <br />&lt;notes&gt;男,1955年生,博士，95年调入海南大学&lt;/notes&gt; <br />&lt;/person&gt; <br />事件回调类SAXHandler.java <br />import java.io.*; <br />import java.util.Hashtable; <br />import org.xml.sax.*; <br />public class SAXHandler extends HandlerBase <br />{ <br />private Hashtable table = new Hashtable(); <br />private String currentElement = null; <br />private String currentValue = null; <br />public void setTable(Hashtable table) <br />{ <br />this.table = table; <br />} <br />public Hashtable getTable() <br />{ <br />return table; <br />} <br />public void startElement(String tag, AttributeList attrs) <br />throws SAXException <br />{ <br />currentElement = tag; <br />} <br />public void characters(char[] ch, int start, int length) <br />throws SAXException <br />{ <br />currentValue = new String(ch, start, length); <br />} <br />public void endElement(String name) throws SAXException <br />{ <br />if (currentElement.equals(name)) <br />table.put(currentElement, currentValue); <br />} <br />} <br />JSP内容显示源码,SaxXml.jsp: <br />&lt;HTML&gt; <br />&lt;HEAD&gt; <br />&lt;TITLE&gt;剖析XML文件people.xml&lt;/TITLE&gt; <br />&lt;/HEAD&gt; <br />&lt;BODY&gt; <br />&lt;%@ page errorPage=&quot;ErrPage.jsp&quot; <br />contentType=&quot;text/html;charset=GB2312&quot; %&gt; <br />&lt;%@ page import=&quot;java.io.*&quot; %&gt; <br />&lt;%@ page import=&quot;java.util.Hashtable&quot; %&gt; <br />&lt;%@ page import=&quot;org.w3c.dom.*&quot; %&gt; <br />&lt;%@ page import=&quot;org.xml.sax.*&quot; %&gt; <br />&lt;%@ page import=&quot;javax.xml.parsers.SAXParserFactory&quot; %&gt; <br />&lt;%@ page import=&quot;javax.xml.parsers.SAXParser&quot; %&gt; <br />&lt;%@ page import=&quot;SAXHandler&quot; %&gt; <br />&lt;% <br />File file = new File(&quot;c:\\people.xml&quot;); <br />FileReader reader = new FileReader(file); <br />Parser parser; <br />SAXParserFactory spf = SAXParserFactory.newInstance(); <br />SAXParser sp = spf.newSAXParser(); <br />SAXHandler handler = new SAXHandler(); <br />sp.parse(new InputSource(reader), handler); <br />Hashtable hashTable = handler.getTable(); <br />out.println(&quot;&lt;TABLE BORDER=2&gt;&lt;CAPTION&gt;教师信息表&lt;/CAPTION&gt;&quot;); <br />out.println(&quot;&lt;TR&gt;&lt;TD&gt;姓名&lt;/TD&gt;&quot; + &quot;&lt;TD&gt;&quot; + <br />(String)hashTable.get(new String(&quot;name&quot;)) + &quot;&lt;/TD&gt;&lt;/TR&gt;&quot;); <br />out.println(&quot;&lt;TR&gt;&lt;TD&gt;学院&lt;/TD&gt;&quot; + &quot;&lt;TD&gt;&quot; + <br />(String)hashTable.get(new String(&quot;college&quot;))+&quot;&lt;/TD&gt;&lt;/TR&gt;&quot;); <br />out.println(&quot;&lt;TR&gt;&lt;TD&gt;电话&lt;/TD&gt;&quot; + &quot;&lt;TD&gt;&quot; + <br />(String)hashTable.get(new String(&quot;telephone&quot;)) + &quot;&lt;/TD&gt;&lt;/TR&gt;&quot;); <br />out.println(&quot;&lt;TR&gt;&lt;TD&gt;备注&lt;/TD&gt;&quot; + &quot;&lt;TD&gt;&quot; + <br />(String)hashTable.get(new String(&quot;notes&quot;)) + &quot;&lt;/TD&gt;&lt;/TR&gt;&quot;); <br />out.println(&quot;&lt;/TABLE&gt;&quot;); <br />%&gt; <br />&lt;/BODY&gt; <br />&lt;/HTML&gt; <br /><br />EJB方面 <br /><br />1、EJB2.0有哪些内容?分别用在什么场合? EJB2.0和EJB1.1的区别? <br />答：规范内容包括Bean提供者，应用程序装配者，EJB容器，EJB配置工具，EJB服务提供者，系统管理员。这里面，EJB容器是EJB之所以能够运行的核心。EJB容器管理着EJB的创建，撤消，激活，去活，与数据库的连接等等重要的核心工作。JSP,Servlet,EJB,JNDI,JDBC,JMS..... <br /><br />2、EJB与JAVA BEAN的区别？ <br />答:Java Bean 是可复用的组件，对Java Bean并没有严格的规范，理论上讲，任何一个Java类都可以是一个Bean。但通常情况下，由于Java Bean是被容器所创建（如Tomcat)的，所以Java Bean应具有一个无参的构造器，另外，通常Java Bean还要实现Serializable接口用于实现Bean的持久性。Java Bean实际上相当于微软COM模型中的本地进程内COM组件，它是不能被跨进程访问的。Enterprise Java Bean 相当于DCOM，即分布式组件。它是基于Java的远程方法调用（RMI）技术的，所以EJB可以被远程访问（跨进程、跨计算机）。但EJB必须被布署在诸如Webspere、WebLogic这样的容器中，EJB客户从不直接访问真正的EJB组件，而是通过其容器访问。EJB容器是EJB组件的代理，EJB组件由容器所创建和管理。客户通过容器来访问真正的EJB组件。 <br /><br />3、EJB的基本架构 <br />答:一个EJB包括三个部分: <br />Remote Interface 接口的代码 <br />package Beans; <br />import javax.ejb.EJBObject; <br />import java.rmi.RemoteException; <br />public interface Add extends EJBObject <br />{ <br />//some method declare <br />} <br />Home Interface 接口的代码 <br />package Beans; <br />import java.rmi.RemoteException; <br />import jaax.ejb.CreateException; <br />import javax.ejb.EJBHome; <br />public interface AddHome extends EJBHome <br />{ <br />//some method declare <br />} <br />EJB类的代码 <br />package Beans; <br />import java.rmi.RemoteException; <br />import javax.ejb.SessionBean; <br />import javx.ejb.SessionContext; <br />public class AddBean Implements SessionBean <br />{ <br />//some method declare <br />} <br /><br />J2EE,MVC方面 <br /><br />1、MVC的各个部分都有那些技术来实现?如何实现? <br />答:MVC是Model－View－Controller的简写。&quot;Model&quot; 代表的是应用的业务逻辑（通过JavaBean，EJB组件实现）， &quot;View&quot; 是应用的表示面（由JSP页面产生），&quot;Controller&quot; 是提供应用的处理过程控制（一般是一个Servlet），通过这种设计模型把应用逻辑，处理过程和显示逻辑分成不同的组件实现。这些组件可以进行交互和重用。 <br /><br />2、应用服务器与WEB SERVER的区别？ <br />希望大家补上，谢谢 <br /><br /><br />3、J2EE是什么？ <br />答:Je22是Sun公司提出的多层(multi-diered),分布式(distributed),基于组件(component-base)的企业级应用模型(enterpriese application model).在这样的一个应用系统中，可按照功能划分为不同的组件，这些组件又可在不同计算机上，并且处于相应的层次(tier)中。所属层次包括客户层(clietn tier)组件,web层和组件,Business层和组件,企业信息系统(EIS)层。 <br /><br />4、WEB SERVICE名词解释。JSWDL开发包的介绍。JAXP、JAXM的解释。SOAP、UDDI,WSDL解释。 <br />答：Web Service描述语言WSDL <br />SOAP即简单对象访问协议(Simple Object Access Protocol)，它是用于交换XML编码信息的轻量级协议。 <br />UDDI 的目的是为电子商务建立标准；UDDI是一套基于Web的、分布式的、为Web Service提供的、信息注册中心的实现标准规范，同时也包含一组使企业能将自身提供的Web Service注册，以使别的企业能够发现的访问协议的实现标准。 <br /><br /><br />5、BS与CS的联系与区别。 <br />希望大家补上，谢谢 <br /><br />6、STRUTS的应用(如STRUTS架构) <br />答：Struts是采用Java Servlet/JavaServer Pages技术，开发Web应用程序的开放源码的framework。 采用Struts能开发出基于MVC(Model-View-Controller)设计模式的应用构架。 Struts有如下的主要功能： <br />一.包含一个controller servlet，能将用户的请求发送到相应的Action对象。 <br />二.JSP自由tag库，并且在controller servlet中提供关联支持，帮助开发员创建交互式表单应用。 <br />三.提供了一系列实用对象：XML处理、通过Java reflection APIs自动处理JavaBeans属性、国际化的提示和消息。 <br /><br />设计模式方面 <br /><br />1、开发中都用到了那些设计模式?用在什么场合? <br />答：每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心。通过这种方式，你可以无数次地使用那些已有的解决方案，无需在重复相同的工作。主要用到了MVC的设计模式。用来开发JSP/Servlet或者J2EE的相关应用。简单工厂模式等。 <br /><br /><br />2、UML方面 <br />答：标准建模语言UML。用例图,静态图(包括类图、对象图和包图),行为图,交互图(顺序图,合作图),实现图, <br /><br />JavaScript方面 <br /><br />1、如何校验数字型? <br />var re=/^\d{1,8}$|\.\d{1,2}$/; <br />var str=document.form1.all(i).value; <br />var r=str.match(re); <br />if (r==null) <br />{ <br />sign=-4; <br />break; <br />} <br />else{ <br />document.form1.all(i).value=parseFloat(str); <br />} <br /><br /><br />CORBA方面 <br /><br />1、CORBA是什么?用途是什么? <br />答：CORBA 标准是公共对象请求代理结构(Common Object Request Broker Architecture)，由对象管理组织 (Object Management Group，缩写为 OMG)标准化。它的组成是接口定义语言(IDL), 语言绑定(binding:也译为联编)和允许应用程序间互操作的协议。 其目的为： <br />用不同的程序设计语言书写 <br />在不同的进程中运行 <br />为不同的操作系统开发 <br /><br /><br />LINUX方面 <br /><br />1、LINUX下线程，GDI类的解释。 <br />答：LINUX实现的就是基于核心轻量级进程的&quot;一对一&quot;线程模型，一个线程实体对应一个核心轻量级进程，而线程之间的管理在核外函数库中实现。 <br />GDI类为图像设备编程接口类库 
					  </div> 
			    <p class="diaryFoot">- 作者： <a href="javascript:void(0);" onClick="window.open('http://publishblog.blogchina.com/blog/postMessage.b?receiver=413486','发送短消息','width=520, height=455')">youyou2005</a>  2005年09月14日, 星期三 12:06　
			    			    <a href="2916217.html#comment">回复（0）</a>
			     |　
			    <a href="2916217.html#trackback">引用（0）</a> 
			    <a href="javascript:void(keyit=window.open('http://blogmark.blogchina.com/jsp/key/quickaddkey.jsp?k='+encodeURI('应聘Java笔试时可能出现问题及其答案 ')+'&u='+encodeURI('http://youyou2005.blogchina.com/youyou2005/2916217.html')+'&c='+encodeURI(''),'keyit','scrollbars=no,width=500,height=430,status=no,resizable=yes'));keyit.focus();">加入博采</a></td>          
			    </p>
			  </div>
						
			  <div class="entity">
			    <h5 class="diaryTitle"><img src="http://blog.blogchina.com/template/common/img/array.gif"
 onclick="{if((document.getElementById('diary2836055')).style.display=='none') {(document.getElementById('diary2836055')).style.display='block'; this.src='http://blog.blogchina.com/template/common/img/array.gif'} else {(document.getElementById('diary2836055')).style.display='none'; this.src='http://blog.blogchina.com/template/common/img/array_2.gif'}}" class="imgShow">
			    <a href="2836055.html">
			    Java 编程技术中汉字问题的分析及解决(从根源上解决) </a>
			    			    </h5>
				<div id="diary2836055" style="display:block
				" class="diaryContent"> 
				      				      <div class="postTitle"><a href="http://blog.csdn.net/whoopee/archive/2005/09/06/473176.aspx">Java 编程技术中汉字问题的分析及解决(从根源上解决)</a><script language="javascript"></script> </div><div class="postText"><div class="diaryContent" id="diary426831" style="DISPLAY: block">很难找到的一篇极棒的文章，它从本质上解决了java的汉字编码问题............<br /><p>在基于 Java 语言的编程中，我们经常碰到汉字的处理及显示的问题。一大堆看不懂的乱码肯定不是我们愿意看到的显示效果，怎样才能够让那些汉字正确显示呢？Java 语言默认的编码方式是UNICODE ，而我们中国人通常使用的文件和数据库都是基于 GB2312 或者 BIG5 等方式编码的，怎样才能够恰当地选择汉字编码方式并正确地处理汉字的编码呢？本文将从汉字编码的常识入手，结合 Java 编程实例，分析以上两个问题并提出解决它们的方案。<br /></p><p>现在 Java 编程语言已经广泛应用于互联网世界，早在 Sun 公司开发 Java 语言的时候，就已经考虑到对非英文字符的支持了。Sun 公司公布的 Java 运行环境（JRE）本身就分英文版和国际版，但只有国际版才支持非英文字符。不过在 Java 编程语言的应用中，对中文字符的支持并非如同 Java Soft 的标准规范中所宣称的那样完美，因为中文字符集不只一个，而且不同的操作系统对中文字符的支持也不尽相同，所以会有许多和汉字编码处理有关的问题在我们进行应用开发中困扰着我们。有很多关于这些问题的解答，但都比较琐碎，并不能够满足大家迫切解决问题的愿望，关于 Java 中文问题的系统研究并不多，本文从汉字编码常识出发，分析 Java 中文问题，希望对大家解决这个问题有所帮助。</p><a name="1"><p align="left"><strong>汉字编码的常识</strong></p><p>我们知道，英文字符一般是以一个字节来表示的，最常用的编码方法是 ASCII 。但一个字节最多只能区分256个字符，而汉字成千上万，所以现在都以双字节来表示汉字，为了能够与英文字符分开，每个字节的最高位一定为1，这样双字节最多可以表示64K格字符。我们经常碰到的编码方式有 GB2312、BIG5、UNICODE 等。关于具体编码方式的详细资料，有兴趣的读者可以查阅相关资料。我肤浅谈一下和我们关系密切的 GB2312 和 UNICODE。GB2312 码，中华人民共和国国家标准汉字信息交换用编码，是一个由中华人民共和国国家标准总局发布的关于简化汉字的编码，通行于中国大陆地区及新加坡，简称<font color="#ff0000">国</font><font color="#ff0000">标码。两个字节中，第一个字节（高字节）的值为区号值加32（20H），第二个字节（低字节）的值为位号值加32（20H），用这两个值来表示一个汉字的编码。</font><font color="#993300">UNICODE 码是微软提出的解决多国字符问题的多字节等长编码，它对英文字符采取前面加&quot;0&quot;字节的策略实现等长兼容。如 &quot;A&quot; 的 ASCII 码为0x41，UNICODE 就为0x00，0x41。利用特殊的工具各种编码之间可以互相转换。</font></p></a><a name="2"><p><strong>Java 中文问题的初步认识</strong></p><p>我们基于 Java 编程语言进行应用开发时，不可避免地要处理中文。Java 编程语言默认的编码方式是 UNICODE，而我们通常使用的数据库及文件都是基于 GB2312 编码的，我们经常碰到这样的情况：浏览基于 JSP 技术的网站看到的是乱码，文件打开后看到的也是乱码，被 Java 修改过的数据库的内容在别的场合应用时无法继续正确地提供信息。</p><p>String sEnglish = &quot;apple&quot;;</p><p>String sChinese = &quot;苹果&quot;;</p><p>String s = &quot;苹果 apple &quot;;</p><p>sEnglish 的长度是5，sChinese的长度是4，而 s 默认的长度是14。对于 sEnglish来说， Java 中的各个类都支持得非常好，肯定能够正确显示。但对于 sChinese 和 s 来说，虽然 Java Soft 声明 Java 的基本类已经考虑到对多国字符的支持（默认 UNICODE 编码），<font color="#ff0000">但是如果操作系统的默认编码不是 UNICODE ，而是国标码等。从 Java 源代码到得到正确的结果，要经过 </font>&quot;<font color="#ff0000">Java 源代码-&gt; Java 字节码-&gt; ;虚拟机-&gt;操作系统-&gt;显示设备&quot;的过程</font>。在上述过程中的每一步骤，我们都必须正确地处理汉字的编码，才能够使最终的显示结果正确。</p><p><font color="#ff0000">&quot; Java 源代码-&gt; Java 字节码&quot;，</font>标准的 Java 编译器 javac 使用的字符集是系统默认的字符集，比如在中文 Windows 操作系统上就是 GBK ,而在 Linux 操作系统上就是ISO-8859-1，所以大家会发现在 Linux 操作系统上编译的类中源文件中的中文字符都出了问题，<font color="#ff0000">解决的办法就是在编译的时候添加 encoding 参数，这样才能够与平台无关。用法是</font></p><p><font color="#ff0000">javac -encoding GBK。</font></p><p><font color="#ff0000">&quot; Java 字节码-&gt;虚拟机-&gt;操作系统&quot;，</font> Java 运行环境 （JRE） 分英文版和国际版，但只有<font color="#ff0000">国际版才支持非英文字符</font>。 Java 开发工具包 （JDK） 肯定支持多国字符，但并非所有的计算机用户都安装了 JDK 。很多操作系统及应用软件为了能够更好的支持 Java ，都内嵌了 JRE 的国际版本，为自己支持多国字符提供了方便。</p><p><font color="#ff0000">&quot;操作系统-&gt;显示设备&quot;，</font>对于汉字来说，操作系统必须支持并能够显示它。英文操作系统如果不搭配特殊的应用软件的话，是肯定不能够显示中文的。</p><p>还有一个问题，就是在 Java 编程过程中，对中文字符进行正确的编码转换。例如，向网页输出中文字符串的时候，不论你是用out.println(string);还是用&lt;%=string%&gt;，都必须作 UNICODE 到 GBK 的转换，或者手动，或者自动。<font color="#ff0000">在 JSP 1.0中，可以定义输出字符集，从而实现内码的自动转换。</font>用法是</p><p>&lt;%@page contentType=&quot;text/html;charset=gb2312&quot; %&gt;</p><p>但是<font color="#ff0000">在一些 JSP 版本中并没有提供对输出字符集的支持，（例如 JSP 0.92），这就需要手动编码输出了</font>，方法非常多。最常用的方法是</p><p>String s1 = request.getParameter(&quot;keyword&quot;);</p><p>String s2 = new String(s1.getBytes(&quot;ISO-8859-1&quot;),&quot;GBK&quot;);</p><p>getBytes 方法用于将中文字符以&quot;ISO-8859-1&quot;编码方式转化成字节数组，而&quot;GBK&quot; 是目标编码方式。我们从以ISO-8859-1方式编码的数据库中读出中文字符串 s1 ，经过上述转换过程，在支持 GBK 字符集的操作系统和应用软件中就能够正确显示中文字符串 s2 。</p></a><a name="3"><p><strong>Java 中文问题的表层分析及处理</strong></p><div align="center"><table cellspacing="0" cellpadding="0" width="80%" border="1"><tbody><tr><td width="100%" colspan="4"><p align="center">背景</p></td></tr><tr><td width="25%"><p align="center">开发环境</p></td><td width="25%"><p align="center">JDK1.15</p></td><td width="25%"><p align="center">Vcafe2.0</p></td><td width="25%"><p align="center">JPadPro</p></td></tr><tr><td width="25%"><p align="center">服务器端</p></td><td width="25%"><p align="center">NT IIS</p></td><td width="25%"><p align="center">Sybase System</p></td><td width="25%"><p align="center">Jconnect（JDBC）</p></td></tr><tr><td width="25%"><p align="center">客户端</p></td><td width="25%"><p align="center">IE5.0</p></td><td width="25%"><p align="center">Pwin98</p></td><td width="25%"><p align="center">?span &gt;</p></td></tr></tbody></table></div><p>.CLASS 文件存放在服务器端，由客户端的浏览器运行 APPLET ， APPLET 只起调入FRAME 类等主程序的作用。界面包括 Textfield ，TextArea，List，Choice 等。</p><p>I.用 JDBC 执行 SELECT 语句从服务器端读取数据（中文）后，将数据用 APPEND 方法加到 TextArea（TA） ，不能正确显示。但加到 List 中时，大部分汉字却可正确显示。</p><p>将数据按&quot;ISO-8859-1&quot; 编码方式转化为字节数组，再按系统缺省编码方式 （Default Character Encoding） 转化为 STRING ，即可在 TA 和 List 中正确显示。</p><p>程序段如下：</p><p>dbstr2 = results.getString(1);</p><p>//After reading the result from DB server，converting it to string.</p><p>dbbyte1 = dbstr2.getBytes(&quot;iso-8859-1&quot;);</p><p>dbstr1 = new String(dbbyte1);</p><p>在转换字符串时不采用系统默认编码方式，而直接采用&quot; GBK&quot; 或者 &quot;GB2312&quot; ,在 A 和 B 两种情况下，从数据库取数据都没有问题。</p><p>II.处理方式与&quot;取中文&quot;相逆，先将 SQL 语句按系统缺省编码方式转化为字节数组，再按&quot;ISO-8859-1&quot;编码方式转化为 STRING ，最后送去执行，则中文信息可正确写入数据库。</p><p>程序段如下：</p><p>sqlstmt = tf_input.getText();</p><p>//Before sending statement to DB server，converting it to sql statement.</p><p>dbbyte1 = sqlstmt.getBytes();</p><p>sqlstmt = newString(dbbyte1,&quot;iso-8859-1&quot;);</p><p>_stmt = _con.createStatement();</p><p>_stmt.executeUpdate(sqlstmt);</p><p>......</p><p>问题：如果客户机上存在 CLASSPATH 指向 JDK 的 CLASSES.ZIP 时（称为 A 情况），上述程序代码可正确执行。但是如果客户机只有浏览器，而没有 JDK 和 CLASSPATH 时（称为 B 情况），则汉字无法正确转换。</p><p>我们的分析：</p><p>1.经过测试，在 A 情况下，程序运行时系统的缺省编码方式为 GBK 或者 GB2312 。在 B 情况下，程序启动时浏览器的 JAVA 控制台中出现如下错误信息：</p><p>Can't find resource for sun.awt.windows.awtLocalization_zh_CN</p><p>然后系统的缺省编码方式为&quot;8859-1&quot;。</p><p>2.如果在转换字符串时不采用系统缺省编码方式，而是直接采用 &quot;GBK&quot; 或&quot;GB2312&quot;，则在 A 情况下程序仍然可正常运行，在 B 情况下，系统出现错误：</p><p>UnsupportedEncodingException。</p><p>3.在客户机上，把 JDK 的 CLASSES.ZIP 解压后，放在另一个目录中， CLASSPATH 只包含该目录。然后一边逐步删除该目录中的 .CLASS 文件，另一边运行测试程序，最后发现在一千多个 CLASS 文件中，只有一个是必不可少的，该文件是：</p><p>sun.io.CharToByteDoubleByte.class。</p><p>将该文件拷到服务器端和其它的类放在一起，并在程序的开头 IMPORT 它，在 B 情况下程序仍然无法正常运行。</p><p>4.在A 情况下，如果在 CLASSPTH 中去掉 sun.io.CharToByteDoubleByte.class ，则程序运行时测得默认编码方式为&quot;8859-1&quot;，否则为 &quot;GBK&quot; 或 &quot;GB2312&quot; 。</p><p>如果 JDK 的版本为1.2以上的话，在 B 情况下遇到的问题得到了很好的解决，测试的步骤同上，有兴趣的读者可以尝试一下。</p></a><a name="4"><p><strong>Java 中文问题的根源分析及解决</strong></p><p>在简体中文 MS Windows 98 + JDK 1.3 下，可以用<font color="#ff0000"> System.getProperties() 得到 Java 运行环境的一些基本属性</font>，类 PoorChinese 可以帮助我们得到这些属性。</p><p>类 PoorChinese 的源代码：</p><p>public class PoorChinese {</p><p>}</p><p>执行 java PoorChinese 后，我们会得到:</p><p>系统变量 file.encoding 的值为 GBK ，user.language 的值为 zh ， user.region 的值为 CN ，这些系统变量的值决定了系统默认的编码方式是 GBK 。</p><p>在上述系统中，下面的代码将 GB2312 文件转换成 Big5 文件，它们能够帮助我们理解 Java 中汉字编码的转化:</p><p>?</p><p>import java.io.*;</p><p>import java.util.*;</p><p /><p>public class gb2big5 {</p><p /><p>static int iCharNum=0;</p><p /><p>public static void main(String[] args) {</p><p>System.out.println(&quot;Input GB2312 file, output Big5 file.&quot;);</p><p>if (args.length!=2) {</p><p>System.err.println(&quot;Usage: jview gb2big5 gbfile big5file&quot;);</p><p>System.exit(1);</p><p>String inputString = readInput(args[0]);</p><p>writeOutput(inputString,args[1]);</p><p>System.out.println(&quot;Number of Characters in file: &quot;+iCharNum+&quot;.&quot;);</p><p>}</p><p /><p>static void writeOutput(String str, String strOutFile) {</p><p>try {</p><p>FileOutputStream fos = new FileOutputStream(strOutFile);</p><p>Writer out = new OutputStreamWriter(fos, &quot;Big5&quot;);</p><p>out.write(str);</p><p>out.close();</p><p>}</p><p>catch (IOException e) {</p><p>e.printStackTrace();</p><p>e.printStackTrace();</p><p>}</p><p>}</p><p>static String readInput(String strInFile) {</p><p>StringBuffer buffer = new StringBuffer();</p><p>try {</p><p>FileInputStream fis = new FileInputStream(strInFile);</p><p>InputStreamReader isr = new InputStreamReader(fis, &quot;GB2312&quot;);</p><p>Reader in = new BufferedReader(isr);</p><p>int ch;</p><p>while ((ch = in.read()) &gt; -1) {</p><p>iCharNum += 1;</p><p>buffer.append((char)ch);</p><p>}</p><p>in.close();</p><p>return buffer.toString();</p><p>}</p><p>catch (IOException e) {</p><p>e.printStackTrace();</p><p>return null;</p><p>}</p><p>}</p><p>}</p><p>?</p><p>编码转化的过程如下：</p><p><font color="#ff0000">GB2312------------------&gt;Unicode-------------&gt;Big5</font></p><p>执行 java gb2big5 gb.txt big5.txt ，如果 gb.txt 的内容是&quot;今天星期三&quot;，则得到的文件 big5.txt 中的字符能够正确显示；而如果 gb.txt 的内容是&quot;情人节快乐&quot;，则得到的文件 big5.txt 中对应于&quot;节&quot;和&quot;乐&quot;的字符都是符号&quot;？&quot;（0x3F），可见 sun.io.ByteToCharGB2312 和 sun.io.CharToByteBig5 这两个基本类并没有编好。</p></a><a name="5"><p>正如上例一样， Java 的基本类也可能存在问题。由于国际化的工作并不是在国内完成的，所以在这些基本类发布之前，没有经过严格的测试，所以对中文字符的支持并不像 Java Soft 所声称的那样完美。前不久，我的一位技术上的朋友发信给我说，他终于找到了 <strong>Java Servlet 中文问题的根源</strong>。两周以来，他一直为 Java Servlet 的中文问题所困扰，因为每面对一个含有中文字符的字符串都必须进行强制转换才能够得到正确的结果（这好象是大家公认的唯一的解决办法）。后来，他确实不想如此继续安分下去了，因为这样的事情确实不应该是高级程序员所要做的工作，他就找出 Servlet 解码的源代码进行分析，因为他怀疑问题就出在解码这部分。经过四个小时的奋斗，他终于找到了问题的根源所在。<font color="#ff0000">原来他的怀疑是正确的， Servlet 的解码部分完全没有考虑双字节，直接把 %XX 当作一个字符。（原来 Java Soft 也会犯这幺低级的错误！）</font></p><p>如果你对这个问题有兴趣或者遇到了同样的烦恼的话，你可以按照他的步骤<strong>对</strong><strong>Servlet.jar 进行修改</strong>：</p></a><a name="6"><p>找到源代码 HttpUtils 中的 static private String parseName ，在返回前将 sb（StringBuffer） 复制成 byte bs[] ，然后 return new String(bs,&quot;GB2312&quot;)。作上述修改后就需要自己解码了：</p><p>HashTable form=HttpUtils .parseQueryString(request.getQueryString())或者</p><p>form=HttpUtils.parsePostData(......)</p><p>千万别忘了编译后放到 Servlet.jar 里面。</p><p>五、 关于 Java 中文问题的总结</p><p>Java 编程语言成长于网络世界，这就要求 Java 对多国字符有很好的支持。 Java 编程语言适应了计算的网络化的需求，为它能够在网络世界迅速成长奠定了坚实的基础。 Java 的缔造者 （Java Soft） 已经考虑到 Java 编程语言对多国字符的支持，只是现在的解决方案有很多缺陷在里面，需要我们付诸一些补偿性的措施。而世界标准化组织也在努力把人类所有的文字统一在一种编码之中，其中一种方案是 ISO10646 ，它用四个字节来表示一个字符。当然，在这种方案未被采用之前，还是希望 Java Soft 能够严格地测试它的产品，为用户带来更多的方便。</p></a></div></div> 
					  </div> 
			    <p class="diaryFoot">- 作者： <a href="javascript:void(0);" onClick="window.open('http://publishblog.blogchina.com/blog/postMessage.b?receiver=413486','发送短消息','width=520, height=455')">youyou2005</a>  2005年09月6日, 星期二 23:46　
			    			    <a href="2836055.html#comment">回复（0）</a>
			     |　
			    <a href="2836055.html#trackback">引用（0）</a> 
			    <a href="javascript:void(keyit=window.open('http://blogmark.blogchina.com/jsp/key/quickaddkey.jsp?k='+encodeURI('Java 编程技术中汉字问题的分析及解决(从根源上解决) ')+'&u='+encodeURI('http://youyou2005.blogchina.com/youyou2005/2836055.html')+'&c='+encodeURI(''),'keyit','scrollbars=no,width=500,height=430,status=no,resizable=yes'));keyit.focus();">加入博采</a></td>          
			    </p>
			  </div>
						
			  <div class="entity">
			    <h5 class="diaryTitle"><img src="http://blog.blogchina.com/template/common/img/array.gif"
 onclick="{if((document.getElementById('diary2836029')).style.display=='none') {(document.getElementById('diary2836029')).style.display='block'; this.src='http://blog.blogchina.com/template/common/img/array.gif'} else {(document.getElementById('diary2836029')).style.display='none'; this.src='http://blog.blogchina.com/template/common/img/array_2.gif'}}" class="imgShow">
			    <a href="2836029.html">
			    JSTL简化JSP编码 </a>
			    			    </h5>
				<div id="diary2836029" style="display:block
				" class="diaryContent"> 
				      				      <p><span class="bodycopy">随着J2EE瘦客户机技术JavaServer Pages(JSP)在过去几年中的流行，独立开发人员已经创建了许多自定义的JSP标记库。虽然很多标记库是编写用来实现不同目标的，但它们往往也对迭代、条件及其他通用操作都提供了类似的解决方案。 </span></p><p><span class="bodycopy">为了减少对解决类似通用问题的独立标记库的需求，在Java Community Process（JSR 52）的赞助下创建了JSTL（JavaServer Pages Standard Tag Library，JSP）标准标记库，为解决这些通用功能提供一个单一的标准解决方案。</span></p><p><span class="topstoryhead">JSTL库</span></p><p><span class="bodycopy">JSTL特别为条件处理、迭代、国际化、数据库访问和可扩展标记语言（XML）处理提供支持。JSTL还引入了expression language（EL，表达式语言），极大地简化了对JSP中应用数据的访问和操作。JSTL包括4个JSP 1.2自定义标记库，每一个都涵盖了一个特定的功能领域。</span></p><p><span class="boldbodycopy">核心（Core）标记库</span><span class="bodycopy">为日常任务提供通用支持，如显示和设置变量、重复使用一组项目、测试条件以及其他操作（如导入和重定向Web内容）。 </span></p><p><span class="boldbodycopy">XML标记库</span><span class="bodycopy">提供了对XML处理和操作的支持，包括XML节点的解析、迭代、基于XML数据的条件评估以及可扩展样式表语言转换（Extensible Style Language Transformations，XSLT）的执行。</span></p><p><span class="boldbodycopy">国际化（Internationalization）标记库</span><span class="bodycopy">支持多语种的应用程序。</span></p><p><span class="boldbodycopy">数据库（Database）标记库</span><span class="bodycopy">对访问和修改数据库数据提供标准化支持。</span></p><p><table cellpadding="5" width="100%" align="center" bgcolor="#f7f7e7" border="1" vspace="5" hspace="5"><tbody><tr><td colspan="4"><center><a name="t1"><span class="parahead1">表1：JSTL的四个标记库 </span></a></center><p /></td></tr><tr bgcolor="#fffff0"><td><span class="boldbodycopy">功能领域 </span></td><td><span class="boldbodycopy">URI</span></td><td><span class="boldbodycopy">前缀</span></td><td><span class="boldbodycopy">例子</span></td></tr><tr><td><span class="bodycopy">核心（Core）</span> </td><td><span class="bodycopy">http://java.sun.com/jstl/core</span></td><td><span class="bodycopy">c</span></td><td><span class="bodycopy">&lt;c:tagname ...&gt;</span></td></tr><tr bgcolor="#fffff0"><td><span class="bodycopy">XML </span></td><td><span class="bodycopy">http://java.sun.com/jstl/xml </span></td><td><span class="bodycopy">x </span></td><td><span class="bodycopy">&lt;x:tagname ...&gt; </span></td></tr><tr><td><span class="bodycopy">国际化（Internationalization）</span></td><td><span class="bodycopy">http://java.sun.com/jstl/fmt </span></td><td><span class="bodycopy">fmt </span></td><td><span class="bodycopy">&lt;fmt:tagname ...&gt; </span></td></tr><tr bgcolor="#fffff0"><td><span class="bodycopy">数据库（Database）</span></td><td><span class="bodycopy">http://java.sun.com/jstl/sql </span></td><td><span class="bodycopy">sql </span></td><td><span class="bodycopy">&lt;sql:tagname ...&gt; </span></td></tr></tbody></table></p><p /><p><span class="parahead1">JSTL入门</span></p><p><span class="bodycopy">初步了解JSTL的最好方法是访问Apache网站--jakarta.apache.org，并下载JSTL的参考实现。在Apache站点还可找到详细的安装指南。可下载的参考实现是一个JAR文件、文档和简单代码示例的组合包。 </span></p><p><span class="bodycopy">要在你的J2EE Web应用程序中使用JSTL，只需简单地将&quot;lib&quot;目录下的JSTL JAR文件复制到你应用程序的WEB-INF/lib目录下。要在一个特定的JSP中使用JSTL标记，你还必须提供一个taglib指令。例如，要将&quot;核心&quot;JSTL库导入到你的页面中，你应该在你的JSP顶端包含下面的指令，如下所示： </span></p><p /><pre>&lt;%@ taglib uri=&quot;http://java.sun.com /jstl/core&quot; prefix=&quot;c&quot; %&gt;
</pre><p /><p><span class="parahead1">JSTL的EL支持</span> </p><p><span class="bodycopy">JSTL的一个重要优势是它采用了简单的expression language（EL），该语言提供一个访问和操作应用程序数据（如存储在servlet上下文中的数据）的简单方式。</span></p><p><span class="bodycopy">EL的语法很简单，而且比Java中具有相同功能的表示要对用户更为友好。例如， pageContext.getAttribute(&quot;aName&quot;)表达式在EL中就成了${aName}。所有的JSTL标记在其属性值中都使用EL表达式。EL表达式在访问嵌套属性时使用${Java.expression}或${ data.reference}格式。数据参考可以是对象及其属性或者对象及其属性数组： </span></p><p /><pre>${myobject.property}
</pre><p /><p><span class="bodycopy">数组存取操作符也用于以索引元素集合显示的数据，如Java数组或java.util.List：</span></p><p /><pre>${myList[2]}$
</pre><p /><p><span class="bodycopy">在EL表达式中除了可以使用属性和数组元素操作符以及算术、关系和逻辑操作符以外，你还可以使用特别操作符来测试对象是否为空。 </span></p><p><span class="bodycopy">除了对象和数组存取，EL还提供了一个完整的常用操作符集合，包括=、!、&lt;、&gt;、&lt;=、&gt;=、+、-、*、/等。 </span></p><p><span class="bodycopy">在任何JSP范围（页面、请求、会话或应用程序）中的对象都可以在EL表达式中引用。例如，如果你有一个带有一个属性&quot;Ename&quot;的Java bean--Employee，那么可以用EL表达式${Employee.Ename}访问这个变量。</span></p><p><span class="bodycopy">除了显式变量，EL还提供了对隐式变量的请求和应答对象中的隐式变量的直接访问。例如，以下语句将访问一个名为&quot;empname&quot;的请求参数： </span></p><p /><pre>${param.empname}
</pre><p /><p><span class="bodycopy">即将推出的JSP 2.0和JSTL 1.0都使用EL。然而，JSP 2.0中使用的EL稍有一点不同。JSTL专家组（JSR-052）已经同意在即将推出的JSTL维护版中使用EL的JSP 2.0版本。 </span></p><p><span class="parahead1">使用JSTL核心标记库</span></p><p><span class="bodycopy">JSTL核心标记库为诸如显示、迭代和设置变量等操作提供了最常用的标记。下面，我们更详细地介绍一些最常用的JSTL核心标记库。首先，在使用任何JSTL核心标记之前，你需要将以下指令添加到你的JSP中：</span></p><p /><pre>&lt;%@ taglib uri=&quot;http://java.sun.com/jstl/core&quot; prefix=&quot;c&quot; %&gt;
</pre><p /><p><span class="bodycopy">你最常使用的JSTL操作之一是显示动态值。为了显示动态数据，核心库提供了c:out标记。c:out标记在一个页面中显示一个EL表达式的值。例如： </span></p><p /><pre>First name: &lt;c:out value=&quot;${Employee.Ename}&quot; /&gt;
</pre><p /><p><span class="bodycopy">c:out的值属性还可以包含文本和表达式的组合：</span> </p><p /><pre>&lt;c:out value=&quot;First name: ${Employee.Ename}&quot; /&gt;
</pre><p /><p><span class="bodycopy">（注意：当JSP 2.0提供对EL的支持时，你无需再使用c:out操作，你可以直接在页面中嵌入JSP表达式。） </span></p><p><span class="bodycopy">另一个操作是设置变量。为了在一个页面中设置变量，核心标记库提供了c:set标记。这个例子显示了将变量Ename设置为参数&quot;enameparm&quot;的值： </span></p><p /><pre>&lt;c:set var=&quot;Ename&quot; value=&quot;${param.
enameparm}&quot; /&gt;
</pre><p /><p><span class="bodycopy">JSTL核心标记库还提供了用于处理条件的标记。c:if处理简单的条件测试。计算test属性中布尔表达式的值；如果是真，计算主体中的内容。在下面的操作中，你还可以看到存储测试结果以备以后在页面（或者在别的地方，如果指定了其他的可选范围属性）中使用的可选的var属性： </span></p><p /><pre>&lt;c:if test=&quot;${Employee.salary &lt;= 10000}&quot; &gt;
It's time for a raise &lt;c:out value=&quot;${Employee.name&quot;&gt;! &lt;/c:if&gt;
</pre><p /><p><span class="bodycopy">下面，你可以看到JSTL通过c:choose、c:when和c:otherwise对跳转逻辑的支持。你可以在一个选择（choose）标记中包含一组c:when操作；如果对c:when块中的表达式求值为真，则不对下面的c:choose操作中的测试进行计算。如果对c:when块中测试求值没有一个为真，则计算c:otherwise操作（如果存在的话）的内容： </span></p><p /><pre>&lt;c:choose&gt;
&lt;c:when test=&quot;${dept.name == 
'development'}&quot;&gt;
...
&lt;/c:when&gt;
&lt;c:when test=&quot;${dept.name == 
'marketing'}&quot;&gt;
...
&lt;/c:when&gt;
&lt;c:otherwise&gt;
...
&lt;/c:otherwise&gt;
&lt;/c:choose&gt;

</pre><p /><p><span class="bodycopy">c:forEach标记提供了一个对元素集合进行迭代的简单方法。如果你只想迭代集合中的部分元素，你可以分别指定开始和结束索引以及带有可选的开始、结束与步进属性的增量值。在下例中，我们对变量empNames中的一个集合的内容进行迭代；在每个循环中，下一个元素被放置在变量名中，并在c:forEach操作的主体中进行求值。 </span></p><p /><pre> 
&lt;table&gt;
&lt;c:forEach var=&quot;name&quot; items=&quot;${empNames}&quot;&gt;
&lt;tr&gt;&lt;td&gt;&lt;c:out value=&quot;${name}&quot;/&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/c:forEach&gt;
&lt;/table&gt;
</pre><p /><p><span class="bodycopy">JSTL核心标记库还可以简化异常处理。以前，你必须将Java try/catch语句放置在Java scriptlet中，或者在错误页面中提供它们。JSTL通过c:catch标记提供了一个处理异常的高明方法，而无需使用scriptlet。 </span></p><p /><pre>&lt;c:catch&gt;
   &lt;!―. . . some set of nested JSTL tags that fire an exception-&gt;

&lt;/c:catch&gt;
</pre><p /><p><span class="bodycopy">可以在<a href="http://jakarta.apache.org/" target="_top"><span class="bodylink">jakarta.apache.org</span></a>的参考实现中提供的JSTL文档中找到其他JSTL标记库如XML、国际化和数据库标记库的例子。</span></p> 
					  </div> 
			    <p class="diaryFoot">- 作者： <a href="javascript:void(0);" onClick="window.open('http://publishblog.blogchina.com/blog/postMessage.b?receiver=413486','发送短消息','width=520, height=455')">youyou2005</a>  2005年09月6日, 星期二 23:43　
			    			    <a href="2836029.html#comment">回复（0）</a>
			     |　
			    <a href="2836029.html#trackback">引用（0）</a> 
			    <a href="javascript:void(keyit=window.open('http://blogmark.blogchina.com/jsp/key/quickaddkey.jsp?k='+encodeURI('JSTL简化JSP编码 ')+'&u='+encodeURI('http://youyou2005.blogchina.com/youyou2005/2836029.html')+'&c='+encodeURI(''),'keyit','scrollbars=no,width=500,height=430,status=no,resizable=yes'));keyit.focus();">加入博采</a></td>          
			    </p>
			  </div>
						
			  <div class="entity">
			    <h5 class="diaryTitle"><img src="http://blog.blogchina.com/template/common/img/array.gif"
 onclick="{if((document.getElementById('diary2617904')).style.display=='none') {(document.getElementById('diary2617904')).style.display='block'; this.src='http://blog.blogchina.com/template/common/img/array.gif'} else {(document.getElementById('diary2617904')).style.display='none'; this.src='http://blog.blogchina.com/template/common/img/array_2.gif'}}" class="imgShow">
			    <a href="2617904.html">
			    阅读贪吃蛇源码 </a>
			    			    </h5>
				<div id="diary2617904" style="display:block
				" class="diaryContent"> 
				      				      <p><font size="2">游戏wormgame是wtk里面自带的demo程序，虽然游戏很简单也很老，就是一般很常见的贪吃蛇游戏。但是既然作为demo程序，那么里面就有很多东西值得我们去思考，去学习。<br />&nbsp;&nbsp;&nbsp; 首先看看这个游戏所采用的数据结构。如果没有看过贪吃蛇的源码，让我们自己选择数据结构，那我们如何选择一个在空间和性能上都很好的数据结构呢。可能很多人首先想到的是链表，符合游戏中的蛇长度的动态增加和减少。但是我们讨论的是用JAVA写的，如果采用链表的话自己需要去封装很多方法。有没有JAVA本来已经封装好的数据结构可以用呢？对，Vector！这是JAVA的一个非常常用而且重要的数据结构。<br />&nbsp;&nbsp;&nbsp; 如果就让我们用Vector来做这个游戏，那Vector里面我们放什么呢？很多人会自然的想到，以组成贪吃蛇的每一个小方格子（在Demo中用的是Cell，英文不好，不知道该用什么词）为对象，然后放到Vector里面去，这样就可以实现贪吃蛇长度的增加和减少，因为增加对应addElement()，减少对应removeElement()。如果这样做的话，那么每一个对象该定义什么数据成员以及封装哪些方法呢？这样做是不是浪费空间了呢？因为当贪吃蛇的长度增长以后，处于中间的小方格子似乎没有起到什么作用。那还有没有更好的方法呢？<br />&nbsp;&nbsp;&nbsp; 让我们现在来看看这个demo是怎么做的吧！<br />&nbsp;&nbsp;&nbsp; 关于贪吃蛇的数据结构方面的类有两个Worm和WormLink，在WormLink的开头作者就写了一段注释：<br />&nbsp;&nbsp;&nbsp;&nbsp; * WormLink represents one sub-section of a worm. Because the<br />&nbsp;&nbsp;&nbsp;&nbsp; * worm will usually contain a few straight segments, this is<br />&nbsp;&nbsp;&nbsp;&nbsp; * a relatively cost effective way to store the entire worm.<br />&nbsp;&nbsp;&nbsp; 所以可以从这里就可以知道作者并不是将每个方格作为对象存到Vector里面的，而是将贪吃蛇的一部份存进去的，其实真正存进去的只是一个带着这个贪吃蛇的很多信息的对象。<br />&nbsp;&nbsp;&nbsp; WormLink的数据成员为 ：<br />&nbsp;&nbsp;&nbsp;&nbsp; private int x, y;<br />&nbsp;&nbsp;&nbsp;&nbsp; private int len;<br />&nbsp;&nbsp;&nbsp;&nbsp; private byte dir;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; 其中封装的方法有（以下只举例我认为比较重要的几个方法）：<br />&nbsp;&nbsp;&nbsp;&nbsp; public void increaseLength() {<br />&nbsp;&nbsp;&nbsp;&nbsp; public void decreaseLength() <br />&nbsp;&nbsp;&nbsp;&nbsp; public int getEndX() <br />&nbsp;&nbsp;&nbsp;&nbsp; public int getEndX()<br />&nbsp;&nbsp;&nbsp;&nbsp; public boolean contains(int x, int y)<br />&nbsp;&nbsp;&nbsp; increaseLength()是增加长度，被封装到这个类里面，因为每个对象都携带了从它开始的长度信息，同理decreaseLength()也是的，至于它们的具体实现，将在下文讲到画图的时候再具体讲。<br />&nbsp;&nbsp;&nbsp; getEndX()，getEndX()的作用是获得贪吃蛇尾部的坐标，从这个方法就可以看出作者的高明之处，并不需要将每个方格子都存到Vector中去。比如初始状态时贪吃蛇的长度为10的话，就不需要向Vector里面存入10个对象，只需要将一个代表的对象存进去就可以了，然后通过getEndX()，getEndX()来获取尾部的信息。这样做既节约空间又方便了以后的处理，特别是画图的处理。<br />&nbsp;&nbsp;&nbsp; contains是碰撞检测简单的函数，在这个游戏里面的碰撞是比较简单的。<br />&nbsp;&nbsp;&nbsp; 下面看类Worm,我们主要看几个重要的函数，同时从这几个函数的处理上面可以看出作者在设计这个游戏时的高明之处。<br />&nbsp; /**<br />&nbsp;&nbsp; * Regenerate the worm in its initial position. This is used<br />&nbsp;&nbsp; * to restart the game after the worm is killed.<br />&nbsp;&nbsp; */<br />&nbsp; public void regenerate() {<br />&nbsp;&nbsp;&nbsp; synchronized (worm) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worm.removeAllElements();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worm.addElement(new WormLink(INIT_X, INIT_Y,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INIT_LEN, INIT_DIR));</font></p><p><font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Reset class variables<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentDirection = 0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; needUpdate = false;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hasEaten = false;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; moveOnNextUpdate = false;<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; } <br />&nbsp;&nbsp;&nbsp; 这是一个初始化的函数，当游戏开始或者从来一次时被调用的函数，这个函数的作用很明显，在此就不作过多的解释了。<br />&nbsp;&nbsp;&nbsp; 下面结合贪吃蛇最简单的移动，从左到右横向移动来说明函数update，paint。<br />&nbsp;&nbsp;&nbsp; 我们先看paint：<br />&nbsp; public void paint(Graphics g) {<br />&nbsp;&nbsp;&nbsp; WormLink sl;<br />&nbsp;&nbsp;&nbsp; int x1, x2, y1, y2;<br />&nbsp;&nbsp;&nbsp; int len;</font></p><p><font size="2">&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; worm.size(); i++) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sl = (WormLink) worm.elementAt(i);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x1 = sl.getX(); x2 = sl.getEndX();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y1 = sl.getY(); y2 = sl.getEndY();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; len = sl.getLength();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawLink(g, x1, y1, x2, y2, len);<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; }&nbsp; <br />&nbsp;&nbsp; 其中函数drawLink的主要作用就是从x1到x2或者y1到y2画len个小方格子，至于其具体实现就不再列出了。<br />&nbsp;&nbsp; 从这个paint函数可以确定我们刚才的推断是正确的，就是整条贪吃蛇是一段一段被存放到vector里面去的，画图的时候又一段一段的画出来的，vector对象worm有多少个元素就存在着多少段。<br />&nbsp;&nbsp; 下面在来看update函数，其实update也是一个画图函数，但是奇怪的是，为什么这个游戏不象别的游戏一样，将所有的画图都放在paint里面呢？这里单独定义一个画图函数的作用又是什么呢？其实我们从这个函数的函数名就可以看出答案了，这个函数的作用是在于更新图像，但是又不是更新整个贪吃蛇，而是根据头和尾部，来部分更新，这样就没有别要在画图的时候，每次都重画整个屏幕，只需要更新贪吃蛇的部分就可以了，这也是一种节省系统开销的方法。虽然对于这个游戏本身来说性能不会有太明显的区别，但是对于一些复杂的游戏，画面丰富的游戏来说，这样做的效果就非常明显了。在后面的Canvas类WormPit里面调用这两个函数的时候，我们可以更加清楚地看到这个作用。<br />&nbsp;&nbsp; 下面讲解update函数的具体实现：<br />&nbsp;&nbsp; <br />&nbsp; public void update(Graphics g) throws WormException {<br />&nbsp;&nbsp;&nbsp; WormLink head, sl;<br />&nbsp;&nbsp;&nbsp; int headX, headY;</font></p><p><font size="2">&nbsp;&nbsp;&nbsp; if (!moveOnNextUpdate) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return;<br />&nbsp;&nbsp;&nbsp; }</font></p><p><font size="2">&nbsp;&nbsp;&nbsp; synchronized (worm) {</font></p><p><font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; head = (WormLink) worm.lastElement(); // the worm 'head'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; head.increaseLength();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!hasEaten) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WormLink tail;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tail = (WormLink) worm.firstElement(); // the worm 'tail'<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tailX = tail.getX();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int tailY = tail.getY();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tail.decreaseLength();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tail.getLength() == 0) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worm.removeElement(tail);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Clear last block of the tail<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.setColor(WormPit.ERASE_COLOUR);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawLink(g, tailX, tailY, tailX, tailY, 1);</font></p><p><font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hasEaten = false;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</font></p><p><font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; needUpdate = false;</font></p><p><font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Make sure we're still in bounds<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (!WormPit.isInBounds(head.getEndX(), head.getEndY())) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new WormException(&quot;over the edge&quot;); // You're dead Jim<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</font></p><p><font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; headX = (byte) head.getEndX();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; headY = (byte) head.getEndY();</font></p><p><font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Draw the head<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.setColor(WormPit.DRAW_COLOUR);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawLink(g, headX, headY, headX, headY, 1);</font></p><p><font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // See if we ate ourself<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (int i = 0; i &lt; worm.size() - 1; i++) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sl = (WormLink) worm.elementAt(i);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (sl.contains(headX, headY)) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throw new WormException(&quot;you ate yourself&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; }<br />&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp; 首先moveOnNextUpdate是用于判断是否将要移动，如果不移动就退出此函数。<br />&nbsp;&nbsp;&nbsp;&nbsp; 我们结合刚才所说的例子，假设此时贪吃蛇是从左到右移动的，其实这个时候worm里面只有一个对象，tail和head是同一个对象。<br />&nbsp;&nbsp;&nbsp;&nbsp; head.increaseLength()，首先将整个蛇的长度加1 ，hasEaten的作用我们暂时不管。然后到tail.decreaseLength()，作用是将长度缩短1，这里我们再回头去看decreaseLength()的实现部分：<br />&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp; public void decreaseLength() {<br />&nbsp;len--;<br />&nbsp;switch (dir) {<br />&nbsp;case Worm.LEFT:<br />&nbsp;&nbsp;&nbsp;&nbsp; x--;<br />&nbsp;&nbsp;&nbsp;&nbsp; break;<br />&nbsp;case Worm.RIGHT:<br />&nbsp;&nbsp;&nbsp;&nbsp; x++;<br />&nbsp;&nbsp;&nbsp;&nbsp; break;<br />&nbsp;case Worm.UP:<br />&nbsp;&nbsp;&nbsp;&nbsp; y--;<br />&nbsp;&nbsp;&nbsp;&nbsp; break;<br />&nbsp;case Worm.DOWN:<br />&nbsp;&nbsp;&nbsp;&nbsp; y++;<br />&nbsp;&nbsp;&nbsp;&nbsp; break;<br />&nbsp;}<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; 从中我们可以看出，这个函数的作用不仅是将长度减1，同时还包括了坐标的移动。对于我们举的这个例子来说，就是tail的x坐标加1。<br />&nbsp;&nbsp;&nbsp; 然后回到函数update:<br />&nbsp;&nbsp;&nbsp; if (tail.getLength() == 0) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worm.removeElement(tail);<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; // Clear last block of the tail<br />&nbsp;&nbsp;&nbsp; g.setColor(WormPit.ERASE_COLOUR);<br />&nbsp;&nbsp;&nbsp; drawLink(g, tailX, tailY, tailX, tailY, 1);<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; 判断语句的作用在于，如果当前尾部所带的长度已经为0了，就要把这个对象从worm中删除。然后就是这个update函数的主要部分了，清除原来的尾部所在的位置，其实就是将原来的小方格画成根背景一样的颜色。<br />&nbsp;&nbsp;&nbsp; isInBounds我们先不管，下面就是该画头了<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; g.setColor(WormPit.DRAW_COLOUR);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; drawLink(g, headX, headY, headX, headY, 1);<br />&nbsp;&nbsp;&nbsp; 其实我们有几个细节需要注意，变量tailX, tailY的赋值是在tail做descreaseLength之前，所以它们记录的是尾部前一个状态下面的位置，然后才将其在画布上面清除。还有一点，在画头的时候，headX, headY的值是head.getEndX()和head.getEndY()，这样我们就知道了，其实存到vector对象worm里面的是贪吃蛇每一段的尾部，对于这个例子来说，就是存放的贪吃蛇最后的那个小方格，当然还有它封装的一些数据信息。而这个时候headX, headY已经是贪吃蛇更新以后头所在的位置，对此例，头的位置已经向前移动了一个单位。<br />&nbsp;&nbsp;&nbsp; 所以对这个例子来说，贪吃蛇的移动过程就是先将长度加1，然后将长度减1并将尾部的x坐标加1，即右移一个单位，然后将原来位置上面的小方格清除掉，再将头的位置右移一个单位并在此位置画头。这样就实现了贪吃蛇的右移了。其实整个过程就只重画了两个方格，尾部和头部。<br />&nbsp;&nbsp;&nbsp; 刚才我们所举的例子跟方向是没有关系的，现在我们来看改变方向的函数。<br />&nbsp;&nbsp;&nbsp; public void setDirection(byte direction) {<br />&nbsp;&nbsp;&nbsp; synchronized (worm) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if ( (direction != currentDirection) &amp;&amp; !needUpdate) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WormLink sl = (WormLink) worm.lastElement();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int x = sl.getEndX();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int y = sl.getEndY();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (direction) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case UP:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (currentDirection != DOWN) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y--;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; needUpdate = true;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case DOWN:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (currentDirection != UP) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; y++;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; needUpdate = true;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case LEFT:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (currentDirection != RIGHT) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x--;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; needUpdate = true;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case RIGHT:<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (currentDirection != LEFT) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x++;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; needUpdate = true;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (needUpdate == true) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; worm.addElement(new WormLink(x, y, 0, direction));<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; currentDirection = direction;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp; } <br />&nbsp; <br />&nbsp;&nbsp;&nbsp; 我们主要看这个函数的最后，如果needUpdate == true我们就要向worm里面添加一个对象，即贪吃蛇的头改变了方向。例如开始蛇从左向右移动，然后再改变方向向上移动，那么就要像worm里面添加一个新的对象，这个时候的贪吃蛇一共有两段，一段是原来的向右移动的水平方向上的一段，还有一段就是刚刚生成的向上移动的一段。如果这个时候贪吃蛇一直向上移动的话，头这一段的长度不断增加，而尾部这段的长度不断减少，当长度减少为0的时候，就将这个尾部的对象从worm里面删除，这样刚新增加的对象就变成了新的尾部了。如果这样不断改变方向下去，整个worm就是这样的添加元素和删除元素的过程。这里我们再回头去看为什么刚开始定义worm的时候用Vector（5，2）了。其实worm里面元素的个数是跟贪吃蛇有多少个弯是一样的，这样开始定义为5个，因为在开始阶段整个贪吃蛇的长度还比较短的时候生成5个新对象的几率是比较小的，所以开始才定义大小为5。<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; 下面我们看canvas类wormPit,首先看paint函数：<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public void paint(Graphics g) {<br />&nbsp;if (forceRedraw) {<br />&nbsp;&nbsp;&nbsp;&nbsp; // Redraw the entire screen<br />&nbsp;&nbsp;&nbsp;&nbsp; forceRedraw = false;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp;&nbsp; // Clear background<br />&nbsp;&nbsp;&nbsp;&nbsp; g.setColor(WormPit.ERASE_COLOUR);<br />&nbsp;&nbsp;&nbsp;&nbsp; g.fillRect(0, 0, getWidth(),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getHeight());</font></p><p><font size="2">&nbsp;&nbsp;&nbsp;&nbsp; // Draw pit border<br />&nbsp;&nbsp;&nbsp;&nbsp; g.setColor(WormPit.DRAW_COLOUR);<br />&nbsp;&nbsp;&nbsp;&nbsp; g.drawRect(1, 1, (width - START_POS), (height - START_POS));</font></p><p><font size="2">&nbsp;&nbsp;&nbsp;&nbsp; // Display current level<br />&nbsp;&nbsp;&nbsp;&nbsp; g.drawString(&quot;L: &quot; + level, START_POS, height, g.TOP|g.LEFT);<br />&nbsp;&nbsp;&nbsp;&nbsp; g.drawString(&quot;&quot; + score,<br />&nbsp;&nbsp;&nbsp; (width - (SCORE_CHAR_WIDTH * 3)),<br />&nbsp;&nbsp;&nbsp; height, g.TOP|g.LEFT);</font></p><p><font size="2">&nbsp;&nbsp;&nbsp;&nbsp; // Display current score<br />&nbsp;&nbsp;&nbsp;&nbsp; g.drawString(&quot;S: &quot;,<br />&nbsp;&nbsp;&nbsp; (width - (SCORE_CHAR_WIDTH * 4)),<br />&nbsp;&nbsp;&nbsp; height, g.TOP|g.RIGHT);<br />&nbsp;&nbsp;&nbsp;&nbsp; g.drawString(&quot;&quot; + score,<br />&nbsp;&nbsp;&nbsp; (width - (SCORE_CHAR_WIDTH * 3)),<br />&nbsp;&nbsp;&nbsp; height, g.TOP|g.LEFT);</font></p><p><font size="2">&nbsp;&nbsp;&nbsp;&nbsp; // Display highest score for this level<br />&nbsp;&nbsp;&nbsp;&nbsp; g.drawString(&quot;H: &quot;,<br />&nbsp;&nbsp;&nbsp; (width - (SCORE_CHAR_WIDTH * 4)),<br />&nbsp;&nbsp;&nbsp; (height + SCORE_CHAR_HEIGHT),<br />&nbsp;&nbsp;&nbsp; g.TOP|g.RIGHT);<br />&nbsp;&nbsp;&nbsp;&nbsp; g.drawString(&quot;&quot; + WormScore.getHighScore(level),<br />&nbsp;&nbsp;&nbsp; (width - (SCORE_CHAR_WIDTH * 3)),<br />&nbsp;&nbsp;&nbsp; (height + SCORE_CHAR_HEIGHT),<br />&nbsp;&nbsp;&nbsp; g.TOP|g.LEFT);</font></p><p><font size="2">&nbsp;&nbsp;&nbsp;&nbsp; // Draw worm &amp; food<br />&nbsp;&nbsp;&nbsp;&nbsp; g.translate(START_POS, START_POS);<br />&nbsp;&nbsp;&nbsp;&nbsp; g.setClip(0, 0, CellWidth*CELL_SIZE, CellHeight*CELL_SIZE);<br />&nbsp;&nbsp;&nbsp;&nbsp; myWorm.paint(g);<br />&nbsp;&nbsp;&nbsp;&nbsp; myFood.paint(g);<br />&nbsp;} else {<br />&nbsp;&nbsp;&nbsp;&nbsp; // Draw worm &amp; food<br />&nbsp;&nbsp;&nbsp;&nbsp; g.translate(START_POS, START_POS);<br />&nbsp;}</font></p><p><font size="2">&nbsp;if (gamePaused) {<br />&nbsp;&nbsp;&nbsp;&nbsp; Font pauseFont = g.getFont();<br />&nbsp;&nbsp;&nbsp;&nbsp; int fontH = pauseFont.getHeight();<br />&nbsp;&nbsp;&nbsp;&nbsp; int fontW = pauseFont.stringWidth(&quot;Paused&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp; g.setColor(WormPit.ERASE_COLOUR);<br />&nbsp;&nbsp;&nbsp;&nbsp; g.fillRect((width-fontW)/2 - 1, (height-fontH)/2,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fontW + 2, fontH);<br />&nbsp;&nbsp;&nbsp;&nbsp; g.setColor(WormPit.TEXT_COLOUR);<br />&nbsp;&nbsp;&nbsp;&nbsp; g.setFont(pauseFont);<br />&nbsp;&nbsp;&nbsp;&nbsp; g.drawString(&quot;Paused&quot;, (width-fontW)/2, (height-fontH)/2,<br />&nbsp;&nbsp;&nbsp; g.TOP|g.LEFT);<br />&nbsp;} else if (gameOver) {<br />&nbsp;&nbsp;&nbsp;&nbsp; Font overFont = g.getFont();<br />&nbsp;&nbsp;&nbsp;&nbsp; int fontH = overFont.getHeight();<br />&nbsp;&nbsp;&nbsp;&nbsp; int fontW = overFont.stringWidth(&quot;Game Over&quot;);<br />&nbsp;&nbsp;&nbsp;&nbsp; g.setColor(WormPit.ERASE_COLOUR);<br />&nbsp;&nbsp;&nbsp;&nbsp; g.fillRect((width-fontW)/2 - 1, (height-fontH)/2,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fontW + 2, fontH);<br />&nbsp;&nbsp;&nbsp;&nbsp; g.setColor(WormPit.TEXT_COLOUR);<br />&nbsp;&nbsp;&nbsp;&nbsp; g.setFont(overFont);<br />&nbsp;&nbsp;&nbsp;&nbsp; g.drawString(&quot;Game Over&quot;, (width-fontW)/2, (height-fontH)/2,<br />&nbsp;&nbsp;&nbsp; g.TOP|g.LEFT);<br />&nbsp;} else {<br />&nbsp;&nbsp;&nbsp;&nbsp; paintPitContents(g);<br />&nbsp;}<br />&nbsp;g.translate(-START_POS, -START_POS);<br />&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; 整个贪吃蛇的活动区域是在黑色边框内，所以通过g.translate(START_POS, START_POS)将坐标原点移动到(START_POS, START_POS)，这个坐标系都作了坐标变换了。<br />&nbsp;&nbsp;&nbsp; 在paint函数的开始通过forceRedraw来判断是否对整个画布进行重画，如果是，（这里这样画分数，level这些东西我们就不具体讲了，直接跳到画myWorm.paint(g)）就调用worm的paint函数，对整个贪吃蛇进行画图。然后再这个paint函数里面调用paintPitContents(g)，这个函数是这个wormPit类的成员函数，也是整个游戏的主要逻辑部分所在。<br />&nbsp;&nbsp;&nbsp; private void paintPitContents(Graphics g) {<br />&nbsp;try {<br />&nbsp;&nbsp;&nbsp;&nbsp; myWorm.update(g);&nbsp;&nbsp;&nbsp; // update worm position<br />&nbsp;&nbsp;&nbsp;&nbsp; if (myFood.isAt(myWorm.getX(), myWorm.getY())) {<br />&nbsp;&nbsp;myWorm.eat();<br />&nbsp;&nbsp;score += level;</font></p><p><font size="2">&nbsp;&nbsp;foodEaten++;</font></p><p><font size="2">&nbsp;&nbsp;if (foodEaten &gt; (level &lt;&lt; 1)) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* Increase difficulty level */<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; forceRedraw = true;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; foodEaten = 0;<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; level++;</font></p><p><font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (tonePlayer != null) {<br />&nbsp;&nbsp;&nbsp;try {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tonePlayer.setMediaTime(0);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tonePlayer.start();<br />&nbsp;&nbsp;&nbsp;} catch (MediaException me) { }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;} else {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (audioPlayer != null) {<br />&nbsp;&nbsp;&nbsp;try {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Manager.playTone(69, 50, 100);&nbsp;&nbsp; // Play audio<br />&nbsp;&nbsp;&nbsp;} catch (MediaException me) { }<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;}</font></p><p><font size="2">&nbsp;&nbsp;g.setColor(WormPit.ERASE_COLOUR);<br />&nbsp;&nbsp;g.fillRect((width - (SCORE_CHAR_WIDTH * 3))-START_POS,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; height-START_POS,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (SCORE_CHAR_WIDTH * 3),<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SCORE_CHAR_HEIGHT);<br />&nbsp;&nbsp;g.setColor(WormPit.DRAW_COLOUR);</font></p><p><font size="2">&nbsp;&nbsp;// Display new score<br />&nbsp;&nbsp;g.drawString(&quot;&quot; + score,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; width - (SCORE_CHAR_WIDTH * 3) - START_POS,<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; height - START_POS, g.TOP|g.LEFT);</font></p><p><font size="2">&nbsp;&nbsp;myFood.regenerate();<br />&nbsp;&nbsp;int x = myFood.getX();<br />&nbsp;&nbsp;int y = myFood.getY();<br />&nbsp;&nbsp;while (myWorm.contains(x, y)) {<br />&nbsp;&nbsp;// generate again if food placed under worm..<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; myFood.regenerate();<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = myFood.getX();&nbsp; y = myFood.getY();<br />&nbsp;&nbsp;}<br />&nbsp;&nbsp;&nbsp;&nbsp; }</font></p><p><font size="2">&nbsp;&nbsp;&nbsp;&nbsp; myFood.paint(g);<br />&nbsp;} catch (WormException se) {<br />&nbsp;&nbsp;&nbsp;&nbsp; gameOver = true;<br />&nbsp;}<br />&nbsp;&nbsp;&nbsp; } <br />&nbsp;&nbsp;&nbsp; <br />&nbsp;&nbsp;&nbsp; 从这个函数的开始我们就可以看到，worm的update函数就是在此被调用的。至此，整个贪吃蛇的数据结构以及如何画图就完成，至于如何处理food这个对象，以及如何处理分数，暂停等，在这里就不讲了。</font></p> 
					  </div> 
			    <p class="diaryFoot">- 作者： <a href="javascript:void(0);" onClick="window.open('http://publishblog.blogchina.com/blog/postMessage.b?receiver=413486','发送短消息','width=520, height=455')">youyou2005</a>  2005年08月17日, 星期三 14:14　
			    			    <a href="2617904.html#comment">回复（0）</a>
			     |　
			    <a href="2617904.html#trackback">引用（0）</a> 
			    <a href="javascript:void(keyit=window.open('http://blogmark.blogchina.com/jsp/key/quickaddkey.jsp?k='+encodeURI('阅读贪吃蛇源码 ')+'&u='+encodeURI('http://youyou2005.blogchina.com/youyou2005/2617904.html')+'&c='+encodeURI(''),'keyit','scrollbars=no,width=500,height=430,status=no,resizable=yes'));keyit.focus();">加入博采</a></td>          
			    </p>
			  </div>
						
			  <div class="entity">
			    <h5 class="diaryTitle"><img src="http://blog.blogchina.com/template/common/img/array.gif"
 onclick="{if((document.getElementById('diary2567578')).style.display=='none') {(document.getElementById('diary2567578')).style.display='block'; this.src='http://blog.blogchina.com/template/common/img/array.gif'} else {(document.getElementById('diary2567578')).style.display='none'; this.src='http://blog.blogchina.com/template/common/img/array_2.gif'}}" class="imgShow">
			    <a href="2567578.html">
			    jsp文件操作</a>
			    			    </h5>
				<div id="diary2567578" style="display:block
				" class="diaryContent"> 
				      				      <p>文件的建立/检查与删除<br />&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt;<br />&lt;%@ page import=&quot;java.io.*&quot;%&gt;<br />&lt;html&gt;<br />&lt;head&gt;<br />&lt;title&gt;文件的建立、检查与删除&lt;/title&gt;<br />&lt;/head&gt;<br />&lt;body&gt;<br />&lt;%<br />String path=request.getRealPath(&quot;&quot;);<br />//out.println(path);<br />File f=new File(path,&quot;File.txt&quot;);<br />//out.println(f);<br />//out.println(f.exists());</p><p>if(f.exists()){//检查File.txt是否存在<br />f.delete();//删除File.txt文件<br />out.println(path + &quot;<a href="file://File.txt/">\\File.txt</a> 存在，已删除。&quot;);<br />}else{<br />f.createNewFile();//在当前目录下建立一个名为File.txt的文件<br />out.println(path + &quot;<a href="file://File.txt/">\\File.txt</a> 不存在，已建立。&quot;);//输出目前所在的目录路径<br />}<br />%&gt;</p><p>目录的建立/检查与删除<br />&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt;<br />&lt;%@ page import=&quot;java.io.*&quot;%&gt;<br />&lt;html&gt;<br />&lt;head&gt;<br />&lt;title&gt;目录的建立/检查与删除&lt;/title&gt;<br />&lt;/head&gt;<br />&lt;body&gt;<br />&lt;%<br />String path=request.getRealPath(&quot;&quot;);<br />path=path + &quot;<a href="file://Sub";//">\\Sub&quot;;//</a>将要建立的目录路径<br />File d=new File(path);//建立代表Sub目录的File对象，并得到它的一个引用<br />if(d.exists()){//检查Sub目录是否存在<br />d.delete();<br />out.println(&quot;Sub目录存在，已删除&quot;);<br />}else{<br />d.mkdir();//建立Sub目录<br />out.println(&quot;Sub目录不存在，已建立&quot;);<br />}<br />%&gt;<br />&lt;/body&gt;<br />&lt;/html&gt;</p><p><br />如何在JSP中处理虚拟目录<br />&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt;<br />&lt;%@ page import=&quot;java.io.*&quot;%&gt;<br />&lt;html&gt;<br />&lt;head&gt;<br />&lt;title&gt;JSP中如何处理虚拟目录&lt;/title&gt;<br />&lt;/head&gt;<br />&lt;body&gt;<br />取得虚拟目录对应的磁盘路径&lt;br&gt;<br />Web站点主目录的位置为&lt;font color=#ff0000&gt;&lt;%=request.getRealPath(&quot;/&quot;)%&gt;&lt;/font&gt;&lt;br&gt;<br />JSP网页所在的目录位置&lt;font color=#ff0000&gt;&lt;%=request.getRealPath(&quot;./&quot;)%&gt;&lt;/font&gt;&lt;br&gt;<br />JSP网页所在目录上一层目录的位置&lt;font color=#ff0000&gt;&lt;%=request.getRealPath(&quot;../&quot;)%&gt;&lt;/font&gt;&lt;br&gt;<br />&lt;/body&gt;<br />&lt;/html&gt;</p><p><br />文件属性的取得<br />&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt;<br />&lt;%@ page import=&quot;java.util.Date,java.io.*&quot;%&gt;<br />&lt;html&gt;<br />&lt;head&gt;<br />&lt;title&gt;文件属性的取得&lt;/title&gt;<br />&lt;/head&gt;<br />&lt;body&gt;<br />&lt;%<br />String path=request.getRealPath(&quot;/&quot;);<br />File f=new File(path,&quot;ReadData.txt&quot;);<br />if(f.exists()){<br />%&gt;<br />&lt;%=f.getName()%&gt;的属性如下：&lt;br&gt;&lt;br&gt;<br />文件长度为：&lt;%=f.length()%&gt;<br />&lt;%=f.isFile()?&quot;是文件&quot;:&quot;不是文件&quot;%&gt;&lt;br&gt;<br />&lt;%=f.isDirectory()?&quot;是目录&quot;:&quot;不是目录&quot;%&gt;&lt;br&gt;<br />&lt;%=f.canRead()?&quot;可读取&quot;:&quot;不可读取&quot;%&gt;&lt;br&gt;<br />&lt;%=f.canWrite()?&quot;可写入&quot;:&quot;不可写入&quot;%&gt;&lt;br&gt;<br />&lt;%=f.isHidden()?&quot;是隐藏文件&quot;:&quot;不是隐藏文件&quot;%&gt;&lt;br&gt;<br />文件的最后修改日期为：&lt;%=new Date(f.lastModified())%&gt;&lt;br&gt;<br />&lt;%<br />}else{<br />f.createNewFile();//在当前目录下建立一个名为ReaData.txt的文件<br />%&gt; <br />&lt;%=f.getName()%&gt;的属性如下：&lt;br&gt;&lt;br&gt;<br />文件长度为：&lt;%=f.length()%&gt;<br />&lt;%=f.isFile()?&quot;是文件&quot;:&quot;不是文件&quot;%&gt;&lt;br&gt;<br />&lt;%=f.isDirectory()?&quot;是目录&quot;:&quot;不是目录&quot;%&gt;&lt;br&gt;<br />&lt;%=f.canRead()?&quot;可读取&quot;:&quot;不可读取&quot;%&gt;&lt;br&gt;<br />&lt;%=f.canWrite()?&quot;可写入&quot;:&quot;不可写入&quot;%&gt;&lt;br&gt;<br />&lt;%=f.isHidden()?&quot;是隐藏文件&quot;:&quot;不是隐藏文件&quot;%&gt;&lt;br&gt;<br />文件的最后修改日期为：&lt;%=new Date(f.lastModified())%&gt;&lt;br&gt;<br />&lt;%<br />}<br />%&gt;<br />&lt;/body&gt;<br />&lt;/html&gt;</p><p><br />取出目录中文件的方法<br />&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt;<br />&lt;%@ page import=&quot;java.io.*&quot;%&gt;<br />&lt;html&gt;<br />&lt;head&gt;<br />&lt;title&gt;取出目录中文件的方法--列出目录中的文件&lt;/title&gt;<br />&lt;/head&gt;<br />&lt;body&gt;<br />&lt;%<br />String path=request.getRealPath(&quot;/&quot;);<br />File d=new File(path);//建立当前目录中文件的File对象<br />File list[]=d.listFiles();//取得代表目录中所有文件的File对象数组<br />out.println(&quot;&lt;font color=#ff0000&gt;&quot; + path + &quot;目录下的文件：&lt;/font&gt;&lt;br&gt;&quot;);<br />for(int i=0;i&lt;list.length;i++){<br />if(list&lt;I&gt;.isFile()){<br />out.println(list&lt;I&gt;.getName() + &quot;&lt;br&gt;&quot;);<br />}<br />}<br />out.println(&quot;&lt;br&gt;&lt;font color=#ff0000&gt;&quot; + path + &quot;目录下的目录：&lt;/font&gt;&lt;br&gt;&quot;);<br />for(int i=0;i&lt;list.length;i++){<br />if(list&lt;I&gt;.isDirectory()){<br />out.println(list&lt;I&gt;.getName() + &quot;&lt;br&gt;&quot;);<br />}<br />}<br />%&gt;<br />&lt;/body&gt;<br />&lt;/html&gt;</p><p><br />判断是否为空白文件<br />&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt;<br />&lt;%@ page import=&quot;java.io.*&quot;%&gt;<br />&lt;html&gt;<br />&lt;head&gt;<br />&lt;title&gt;判断是否为空白文件&lt;/title&gt;<br />&lt;/head&gt;<br />&lt;body&gt;<br />&lt;%<br />String path=request.getRealPath(&quot;/&quot;);<br />out.println(path);<br />FileReader fr=new FileReader(path + &quot;<a href="file://AtEnd.txt");//">\\AtEnd.txt&quot;);//</a>建立FileReader对象，并实例化为fr<br />//对FileReader类生成的对象使用read()方法，可以从字符流中读取下一个字符。<br />if(fr.read()==-1)//判断是否已读到文件的结尾<br />{<br />out.print(&quot;AtEnd.txt文件中没有数据&lt;br&gt;&quot;);<br />}else{<br />out.println(&quot;AtEnd.txt文件中有数据&quot;);<br />}<br />fr.close();<br />%&gt;<br />&lt;/body&gt;<br />&lt;/html&gt;</p><p><br />读取所有的文件数据<br />&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt;<br />&lt;%@ page import=&quot;java.io.*,java.lang.*&quot;%&gt;<br />&lt;html&gt;<br />&lt;head&gt;<br />&lt;title&gt;读取所有的文件数据&lt;/title&gt;<br />&lt;/head&gt;<br />&lt;body&gt;<br />&lt;%<br />String path=request.getRealPath(&quot;.&quot;);<br />FileReader fr=new FileReader(path + &quot;<a href="file://ReadData.txt/">\\ReadData.txt</a>&quot;);<br />//关键在于读取过程中，要判断所读取的字符是否已经到了文件的末尾，并且这个字符是不是文件中的断行符，即判断该字符值是否为13。<br />int c=fr.read();//从文件中读取一个字符<br />//判断是否已读到文件结尾<br />while(c!=-1){<br />out.print((char)c);//输出读到的数据<br />c=fr.read();//从文件中继续读取数据<br />if(c==13){//判断是否为断行字符<br />out.print(&quot;&lt;br&gt;&quot;);//输出分行标签<br />fr.skip(1);//略过一个字符<br />//c=fr.read();//读取一个字符<br />}<br />}<br />fr.close();<br />%&gt;<br />&lt;/body&gt;<br />&lt;/html&gt;</p><p><br />一行一行读取数据<br />&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt;<br />&lt;%@ page import=&quot;java.io.*&quot;%&gt;<br />&lt;html&gt;<br />&lt;head&gt;<br />&lt;title&gt;文件读取&lt;/title&gt;<br />&lt;/head&gt;<br />&lt;body&gt;<br />&lt;%<br />String path=request.getRealPath(&quot;&quot;);//取得当前目录的路径<br />FileReader fr=new FileReader(path + &quot;<a href="file://file//inc//t.txt");//">\\file\\inc\\t.txt&quot;);//</a>建立FileReader对象，并实例化为fr<br />BufferedReader br=new BufferedReader(fr);//建立BufferedReader对象，并实例化为br<br />String Line=br.readLine();//从文件读取一行字符串<br />//判断读取到的字符串是否不为空<br />while(Line!=null){<br />out.println(Line + &quot;&lt;br&gt;&quot;);//输出从文件中读取的数据<br />Line=br.readLine();//从文件中继续读取一行数据<br />}<br />br.close();//关闭BufferedReader对象<br />fr.close();//关闭文件<br />%&gt;<br />&lt;/body&gt;<br />&lt;/html&gt;</p><p><br />略过文件中的字符不读取<br />&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt;<br />&lt;%@ page import=&quot;java.io.*&quot;%&gt;<br />&lt;html&gt;<br />&lt;head&gt;<br />&lt;title&gt;略过字节不读取&lt;/title&gt;<br />&lt;/head&gt;<br />&lt;body&gt;<br />&lt;%<br />String path=request.getRealPath(&quot;.&quot;);<br />FileReader fr=new FileReader(path + &quot;<a href="file://ReadData.txt/">\\ReadData.txt</a>&quot;);<br />fr.skip(2);//跳过2个字节<br />int c=fr.read();//读取一个字节<br />while(c!=-1){<br />out.print((char)c);<br />c=fr.read();<br />}<br />fr.close();<br />%&gt;<br />&lt;/body&gt;<br />&lt;/html&gt;</p><p><br />将数据写入文件<br />&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt;<br />&lt;%@ page import=&quot;java.io.*&quot;%&gt;<br />&lt;html&gt;<br />&lt;head&gt;<br />&lt;title&gt;将数据写入文件&lt;/title&gt;<br />&lt;/head&gt;<br />&lt;body&gt;<br />&lt;%<br />String path=request.getRealPath(&quot;.&quot;);<br />FileWriter fw=new FileWriter(path + &quot;<a href="file://WriteData.txt");//">\\WriteData.txt&quot;);//</a>建立FileWriter对象，并实例化fw<br />//将字符串写入文件<br />fw.write(&quot;大家好！&quot;);<br />fw.write(&quot;本书是《JSP编程技巧》&quot;);<br />fw.write(&quot;请多多指教！&quot;);<br />fw.write(&quot;email:stride@sina.com&quot;);<br />fw.close();</p><p>FileReader fr=new FileReader(path + &quot;<a href="file://WriteData.txt/">\\WriteData.txt</a>&quot;);<br />BufferedReader br=new BufferedReader(fr);//建立BufferedReader对象，并实例化为br<br />String Line=br.readLine();<br />//读取一行数据<br />out.println(Line + &quot;&lt;br&gt;&quot;);<br />br.close();//关闭BufferedReader对象<br />fr.close();<br />%&gt;<br />&lt;/body&gt;<br />&lt;/html&gt;</p><p><br />将写入文件的数据分行<br />&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt;<br />&lt;%@ page import=&quot;java.io.*&quot;%&gt;<br />&lt;html&gt;<br />&lt;head&gt;<br />&lt;title&gt;将写入文件的数据分行&lt;/title&gt;<br />&lt;/head&gt;<br />&lt;body&gt;<br />&lt;%<br />String path=request.getRealPath(&quot;.&quot;);<br />FileWriter fw=new FileWriter(path + &quot;<a href="file://WriteData.txt/">\\WriteData.txt</a>&quot;);<br />BufferedWriter bw=new BufferedWriter(fw);<br />bw.write(&quot;大家好！&quot;);<br />bw.write(&quot;本书是《JSP编程技巧》。&quot;);<br />bw.newLine();//断行<br />bw.write(&quot;请多多指教！&quot;);<br />bw.newLine();//断行<br />bw.write(&quot;email: <a href="mailto:stride@sina.com">stride@sina.com</a>&quot;);<br />bw.flush();//将数据更新至文件<br />fw.close();//关闭文件流<br />out.println(&quot;写入文件内容为：&lt;br&gt;&quot;);<br />FileReader fr=new FileReader(path + &quot;<a href="file://WriteData.txt/">\\WriteData.txt</a>&quot;);<br />BufferedReader br=new BufferedReader(fr);<br />String Line=br.readLine();//读取一行数据<br />while(Line!=null){<br />out.println(Line + &quot;&lt;br&gt;&quot;);<br />Line=br.readLine();<br />}<br />fr.close();<br />%&gt;<br />&lt;/body&gt;<br />&lt;/html&gt;<br />如何将数据追加写入到文件<br />&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt;<br />&lt;%@ page import=&quot;java.io.*&quot;%&gt;<br />&lt;html&gt;<br />&lt;head&gt;<br />&lt;title&gt;将写入文件的数据分行&lt;/title&gt;<br />&lt;/head&gt;<br />&lt;body&gt;<br />&lt;%<br />String path=request.getRealPath(&quot;.&quot;);<br />RandomAccessFile rf=new RandomAccessFile(path + &quot;<a href="file://WriteData.txt","rw");//">\\WriteData.txt&quot;,&quot;rw&quot;);//</a>定义一个类RandomAccessFile的对象，并实例化<br />rf.seek(rf.length());//将指针移动到文件末尾<br />rf.writeBytes(&quot;\nAppend a line to the file!&quot;);<br />rf.close();//关闭文件流<br />out.println(&quot;写入文件内容为：&lt;br&gt;&quot;);<br />FileReader fr=new FileReader(path + &quot;<a href="file://WriteData.txt/">\\WriteData.txt</a>&quot;);<br />BufferedReader br=new BufferedReader(fr);//读取文件的BufferedRead对象<br />String Line=br.readLine();<br />while(Line!=null){<br />out.println(Line + &quot;&lt;br&gt;&quot;);<br />Line=br.readLine();<br />}<br />fr.close();//关闭文件<br />%&gt;<br />&lt;/body&gt;<br />&lt;/html&gt;&lt;/I&gt;&lt;/I&gt;&lt;/I&gt;&lt;/I&gt;<br /></p> 
					  </div> 
			    <p class="diaryFoot">- 作者： <a href="javascript:void(0);" onClick="window.open('http://publishblog.blogchina.com/blog/postMessage.b?receiver=413486','发送短消息','width=520, height=455')">youyou2005</a>  2005年08月12日, 星期五 16:37　
			    			    <a href="2567578.html#comment">回复（0）</a>
			     |　
			    <a href="2567578.html#trackback">引用（0）</a> 
			    <a href="javascript:void(keyit=window.open('http://blogmark.blogchina.com/jsp/key/quickaddkey.jsp?k='+encodeURI('jsp文件操作')+'&u='+encodeURI('http://youyou2005.blogchina.com/youyou2005/2567578.html')+'&c='+encodeURI(''),'keyit','scrollbars=no,width=500,height=430,status=no,resizable=yes'));keyit.focus();">加入博采</a></td>          
			    </p>
			  </div>
						
			  <div class="entity">
			    <h5 class="diaryTitle"><img src="http://blog.blogchina.com/template/common/img/array.gif"
 onclick="{if((document.getElementById('diary2490191')).style.display=='none') {(document.getElementById('diary2490191')).style.display='block'; this.src='http://blog.blogchina.com/template/common/img/array.gif'} else {(document.getElementById('diary2490191')).style.display='none'; this.src='http://blog.blogchina.com/template/common/img/array_2.gif'}}" class="imgShow">
			    <a href="2490191.html">
			    java 学习步骤</a>
			    			    </h5>
				<div id="diary2490191" style="display:block
				" class="diaryContent"> 
				      				      J2EE又包括许多组件，如JSP,Servlet,JavaBean,EJB,JDBC,JavaMail等。要学习起来可不是一两天的事。<br /><br />那么又该如何学习J2EE呢？当然Java语法得先看一看的，I/O包，Util包，Lang包你都熟悉了吗？然后再从JSP学起。如果你学过HTML，那么事情要好办的多，如果没有，那你快去补一补HTML基础吧。其实JSP中的Java语法也不多，它更象一个脚本语言，有点象ASP。然后你就该学一学Servlet了。Servlet就是服务器端小程序，他负责生成发送给客户端的HTML文件。JSP在执行时，也是先转换成Servlet再运行的。虽说JSP理论上可以完全取代Servlet，这也是SUN推出JSP的本意，可是Servlet用来控制流程跳转还是挺方便的，也令程序更清晰。接下来你应该学习一下Javabean了，可能你早就看不管JSP在HTML中嵌Java代码的混乱方式了，这种方式跟ASP又有什么区别呢？还好，SUN提供了Javabean可以把你的JSP中的Java代码封装起来，便于调用也便于重用。接着就是EJB了，EJB就是Enterprise JavaBean，看名字好象它是Javabean，可是它和Javabean还是有区别的。它是一个体系结构，你可以搭建更安全、更稳定的企业应用。它的大量代码已由中间件（也就是我们常听到的Weblogic,Websphere这些J2EE服务器）完成了，所以我们要做的程序代码量很少，大部分工作都在设计和配置中间件上。至于JDBC，就不用我多说了，你如果用java编过存取数据库的程序，就应该很熟悉。还有，如果你要用Java编发送电子邮件的程序，你就得看看JavaMail了。<br /><br />好了，对Java和J2EE有了一些基本概念之后，你就应该编一些程序了，千万不要纸上谈兵哦。最好找一些有实例且带光盘的书来看，这样看到好的程序就可以直接Ctrl+C再Ctrl+V，也不用劳您老大架再亲自把它 再输一遍吧，再说直接复制还不用怕出错，何乐而不为呢！还有就是要经常上一些好的Java编程文章，有好的文章要Cut下来，有问题尽管问，只要问题不是太傻，一般高手都会回答你的。下面介绍几个好的Java方面的编程网站： <br />CSDN论坛 <a class="ilink" href="http://www.csdn.net/" target="_blank"><font color="#004080">http://www.csdn.net/</font></a> 中国最有名的技术论坛，《程序员》杂志就是他们出版的，你可以在上面提出问题，马上就有人回答你，如果你觉得好，你可以给那人加分； <br />Java研究组织 <a class="ilink" href="http://www.javaresearch.org/" target="_blank">http://www.javaresearch.org/</a> 上面有很多原创文章，高手还是挺多的； <br />Java开发者 <a class="ilink" href="http://www.chinajavaworld.com/" target="_blank">http://www.chinajavaworld.com/</a> 那里Java资料比较全； <br />java.com.cn <a class="ilink" href="http://www.java.com.cn/" target="_blank">http://www.java.com.cn/</a> 看这域名就知道有多牛，注册用户快接近一万了，同时在线人数也在一千左右，人气很旺的； <br />IBM的开发者网络 <a class="ilink" href="http://www-900.ibm.com/developerWorks/cn/java/index.shtml" target="_blank">http://www-900.ibm.com/developerWorks/cn/java/index.shtml</a> IBM永远的蓝色巨人； <br /><br />那么我书也看了，程序也做了，别人问我的问题我都能解决了，是不是就成为高手了呢？当然没那么简单，这只是万里长征走完了第一步。不信？那你出去接一个项目，你知道怎么下手吗，你知道怎么设计吗，你知道怎么组织人员进行开发吗？你现在脑子里除了一些散乱的代码之外，可能再没有别的东西了吧！你现在最缺的是实际的工作经验，而不是书本上那些凭空想出来的程序。所以你快去找一份Java的编程工作来做吧（如果是在校学生可以去做兼职啊），在实践中提高自己，那才是最快的。不过你得祈祷在公司里碰到一个高手，而且他还愿意不厌其烦地教你，这样好象有点难哦！ <br /><br />还有一个办法就是读开放源码的程序了。我们知道开放源码大都出自高手，他们设计合理，考虑周到，再加上有广大的程序员参与，代码的价值自然是字字珠叽，铿锵有力（对不起，偶最近《金装四大才子》看多了）。学Java必读的两个开源程序就是Jive和Pet Store。<br /><br />Jive是国外一个非常著名的BBS程序，完全开放源码。论坛的设计采用了很多先进的技术，如Cache、用户认证、Filter、XML等，而且论坛完全屏蔽了对数据库的访问，可以很轻易的在不同数据库中移植。论坛还有方便的安装和管理程序，这是我们平时编程时容易忽略的一部份（中国程序员一般只注重编程的技术含量，却完全不考虑用户的感受，这就是我们与国外软件的差距所在）。Jive的资料在很多网站上都有，大家可以找来研究一下。相信你读完代码后，会有脱胎换骨的感觉。遗憾的是Jive从2.5以后就不再无条件的开放源代码，同时有licence限制。不过幸好还有中国一流的Java程序员关注它，外国人不开源了，中国人就不能开源吗？这里向大家推荐一个汉化的Jive版本―J道。Jive(J道版)是由中国Java界大名鼎鼎的banq在Jive 2.1版本基础上改编而成, 全中文，增加了一些实用功能，如贴图，用户头像和用户资料查询等，而且有一个开发团队在不断升级。你可以访问banq的网站 <a class="ilink" href="http://www.jdon.com/" target="_blank">http://www.jdon.com/</a> 去下载，或到同济技术论坛的服务器上 <a class="ilink" href="ftp://nro.shtdu.edu.cn/" target="_blank">ftp://nro.shtdu.edu.cn</a> 去下，安装上有什么问题，可以到论坛上去提问。<br /><br />Pet Store（宠物店）是SUN公司为了演示其J2EE编程规范而推出的开放源码的程序，应该很具有权威性，想学J2EE和EJB的朋友不要错过了。 <br /><br />你一定会高兴地说，哈哈，原来成为Java高手就这么简单啊！记得Tomjava也曾碰到过一个项目经理，号称Java很简单，只要三个月就可以学会。其实说这种话的人就如当年小日本号称“三个月拿下中国”一样大言不惭。不是Tomjava泼你冷水，你现在只是学到了Java的骨架，却还没有学到Java的精髓。接下来你得研究设计模式了。设计模式是高级程序员真正掌握面向对象核心思想的必修课。设计模式并不是一种具体&quot;技术&quot;,它讲述的是思想，它不仅仅展示了接口或抽象类在实际案例中的灵活应用和智慧，让你能够真正掌握接口或抽象类的应用，从而在原来的Java语言基础上跃进一步，更重要的是，设计模式反复向你强调一个宗旨：要让你的程序尽可能的可重用。<br /><br />关于设计模式的资料，还是向大家推荐banq的网站 <a class="ilink" href="http://www.jdon.com/" target="_blank">http://www.jdon.com/</a> ，他把GOF的23种模式以通俗易懂的方式诠释出来，纯Java描述，真是经典中的经典。有时间再研究一下MVC结构（把Model-View-Control分离开的设计思想）吧，现在很流行的Struts就是它的一种实现方式，不过Struts用起来实在是很繁，我们只要学习其精髓即可，我们完全可以设计自己的MVC结构。然后你再研究一下软件Refactoring(重整)和极限XP编程，相信你又会上一个台阶。 <br /><br />做完这些，你不如整理一下你的Java代码，把那些经典的程序和常见的应用整理出来，再精心打造一番，提高其重用性和可扩展性。你再找几个志同道合的朋友成立一个工作室吧，你可以去承接一些项目做了，一开始可能有些困难，可是你有技术积累，又考虑周全，接下项目来可以迅速作完，相信大家以后都会来找你的，所以Money就哗啦啦的来了。。。。。。 <br /><br />当然你也可以参加一些开源项目，一方面可以提高自己，另一方面也是为中国软件事业做贡献嘛！开发者在互联网上用CVS合作开发，用QQ,MSN,E-mail讨论联系，天南海北的程序员分散在各地却同时开发同一个软件，是不是很有意思呢？ <br />下面介绍两个好的开源项目网站： <br />湖北省软件公共开发平台 <a class="ilink" href="http://gro.clinux.org/" target="_blank">http://gro.clinux.org/</a> <br />共创联盟 <a class="ilink" href="http://cosoft.org.cn/" target="_blank">http://cosoft.org.cn/</a> <br /><br />哇，好高兴哦，我终于成为高手了！非也，非也。古人云：“识时务者为俊杰”。你知道计算机界现在的发展形势吗？你知道微软的.NET蓝图和SUN ONE计划之间的明争暗斗吗?你知道计算机技术将向何处发展吗?其实从各大计算机厂商最近的动作,都可以看出来“Web服务将是下一代互联网应用的制高点”，而微软的.NET蓝图和SUN ONE计划的斗争焦点，也就是Web服务。Web服务就是一个崭新的分布式计算模型，它是一系列标准的综合（XML,SOAP,UDDI,WSDL和WSFL等）。它使得不同语言编写的软件能够轻易的集成起来，使网络资源和Web站点变成一种服务而不是混乱的垃圾场。不远的将来，我们就可以在家里点击一下鼠标，就可以完成出门旅游的全部准备工作，包括定飞机票，定旅游线路，定好房间等。请注意，这所有的一切都是Web站点间自动完成的，再也不用象现在一样，表面上是电子商务，实际上很多环节都是人工操作。也许你会觉得这是天方夜谈，不过就近的说，你也很有可能承接一个项目，要集成两个企业的ERP系统。很有可能上游企业的系统是用Delphi编的，而下游企业的系统是用Java编的。你说你是Java高手，大家都看者你怎么做呢。所以啊，你还得学习新技术，如Web服务，而且你Delphi也要懂一点吧（Delphi6现在已经提供Web服务的控件了）。 你编的Java系统，可能要和.NET集成，所以你.NET要懂一点吧？到最后，你可能发现你已经成为Java高手了，但很多时间却在搞别的技术。太极张三丰里说，最厉害的招式就是没有招式，可能就是这个道理吧！ <br /><br />因为刚刚兴起，所以网上Web服务的资料不是很多，我还是给大家推荐几个网站吧： <br />中国UDDI技术联盟 <a class="ilink" href="http://www.uddi-china.org/" target="_blank">http://www.uddi-china.org/</a> <br />CSDN的柴晓路专栏 <a class="ilink" href="http://www.csdn.net/develop/author/ColumnAuthor/fennivel/" target="_blank">http://www.csdn.net/develop/author/ColumnAuthor/fennivel/</a> （注：柴晓路也是互联网上一个有名的人物，他发表过很多关于Web服务的文章，还出了一书，应该称的上是中国Web服务技术的先行者） <br />IBM的开发者网络的XML&amp;Web Service专栏: <a class="ilink" href="http://www-900.ibm.com/developerWorks/cn/xml/index.shtml?csdn" target="_blank">http://www-900.ibm.com/developerWorks/cn/xml/index.shtml?csdn</a> IBM可是Web服务的力推者 <br /> 
					  </div> 
			    <p class="diaryFoot">- 作者： <a href="javascript:void(0);" onClick="window.open('http://publishblog.blogchina.com/blog/postMessage.b?receiver=413486','发送短消息','width=520, height=455')">youyou2005</a>  2005年08月5日, 星期五 10:01　
			    			    <a href="2490191.html#comment">回复（0）</a>
			     |　
			    <a href="2490191.html#trackback">引用（0）</a> 
			    <a href="javascript:void(keyit=window.open('http://blogmark.blogchina.com/jsp/key/quickaddkey.jsp?k='+encodeURI('java 学习步骤')+'&u='+encodeURI('http://youyou2005.blogchina.com/youyou2005/2490191.html')+'&c='+encodeURI(''),'keyit','scrollbars=no,width=500,height=430,status=no,resizable=yes'));keyit.focus();">加入博采</a></td>          
			    </p>
			  </div>
						
			  <div class="entity">
			    <h5 class="diaryTitle"><img src="http://blog.blogchina.com/template/common/img/array.gif"
 onclick="{if((document.getElementById('diary2395593')).style.display=='none') {(document.getElementById('diary2395593')).style.display='block'; this.src='http://blog.blogchina.com/template/common/img/array.gif'} else {(document.getElementById('diary2395593')).style.display='none'; this.src='http://blog.blogchina.com/template/common/img/array_2.gif'}}" class="imgShow">
			    <a href="2395593.html">
			    每个java初学者都应该搞懂的问题！</a>
			    			    </h5>
				<div id="diary2395593" style="display:block
				" class="diaryContent"> 
				      				      <font size="2">对于这个系列里的问题，每个学Java的人都应该搞懂。当然，如果只是学Java玩玩就无所谓了。如果你认为自己已经超越初学者了，却不很懂这些问题，请将你自己重归初学者行列。内容均来自于CSDN的经典老贴。<br /><br />问题一：我声明了什么！<br /><br />String s = &quot;Hello world!&quot;;<br /><br />许多人都做过这样的事情，但是，我们到底声明了什么？回答通常是：一个String，内容是“Hello world!”。这样模糊的回答通常是概念不清的根源。如果要准确的回答，一半的人大概会回答错误。<br />这个语句声明的是一个<font color="#ff0000">指向对象的引用</font>，名为“s”，可以指向类型为String的任何对象，目前指向&quot;Hello world!&quot;这个String类型的对象。这就是真正发生的事情。我们并没有声明一个String对象，我们只是声明了一个只能指向String对象的引用变量。所以，如果在刚才那句语句后面，如果再运行一句：<br /><br />String string = s;<br /><br />我们是声明了另外一个只能指向String对象的引用，名为string，并没有第二个对象产生，string还是指向原来那个对象，也就是，和s指向同一个对象。<br /><br />问题二：&quot;==&quot;和equals方法究竟有什么区别？<br /><br />==操作符专门用来比较变量的值是否相等。比较好理解的一点是：<br />int a=10;<br />int b=10;<br />则a==b将是true。<br />但不好理解的地方是：<br />String a=new String(&quot;foo&quot;);<br />String b=new String(&quot;foo&quot;);<br />则a==b将返回false。<br /><br />根据前一帖说过，对象变量其实是一个引用，它们的值是指向对象所在的内存地址，而不是对象本身。a和b都使用了new操作符，意味着将在内存中产生两个内容为&quot;foo&quot;的字符串，既然是“两个”，它们自然位于不同的内存地址。a和b的值其实是两个不同的内存地址的值，所以使用&quot;==&quot;操作符，结果会是false。诚然，a和b所指的对象，它们的内容都是&quot;foo&quot;，应该是“相等”，但是==操作符并不涉及到对象内容的比较。<br />对象内容的比较，正是equals方法做的事。<br /><br />看一下Object对象的equals方法是如何实现的：<br />boolean equals(Object o){<br /><br />return this==o;<br /><br />}<br />Object对象默认使用了==操作符。<font color="#ff0000">所以如果你自创的类没有覆盖equals方法，那你的类使用equals和使用==会得到同样的结果。</font>同样也可以看出，Object的equals方法没有达到equals方法应该达到的目标：比较两个对象内容是否相等。因为答案应该由类的创建者决定，所以Object把这个任务留给了类的创建者。<br /><br />看一下一个极端的类：<br />Class Monster{<br />private String content;<br />...<br />boolean equals(Object another){ return true;}<br /><br />}<br />我覆盖了equals方法。这个实现会导致无论Monster实例内容如何，它们之间的比较永远返回true。<br /><br />所以当你是用equals方法判断对象的内容是否相等，请不要想当然。因为可能你认为相等，而这个类的作者不这样认为，而类的equals方法的实现是由他掌握的。如果你需要使用equals方法，或者使用任何基于散列码的集合（HashSet,HashMap,HashTable），请察看一下java doc以确认这个类的equals逻辑是如何实现的。<br /><br />问题三：String到底变了没有？<br /><br />没有。因为<font color="#ff0000">String被设计成不可变(immutable)类</font>，所以它的所有对象都是不可变对象。请看下列代码：<br /><br />String s = &quot;Hello&quot;;<br />s = s + &quot; world!&quot;;<br /><br />s所指向的对象是否改变了呢？从本系列第一篇的结论很容易导出这个结论。我们来看看发生了什么事情。在这段代码中，s原先指向一个String对象，内容是&quot;Hello&quot;，然后我们对s进行了+操作，那么s所指向的那个对象是否发生了改变呢？答案是没有。这时，s不指向原来那个对象了，而指向了另一个String对象，内容为&quot;Hello world!&quot;，原来那个对象还存在于内存之中，只是s这个引用变量不再指向它了。<br />通过上面的说明，我们很容易导出另一个结论，如果经常对字符串进行各种各样的修改，或者说，不可预见的修改，那么<font color="#0033ff">使用String来代表字符串的话会引起很大的内存开销</font>。因为String对象建立之后不能再改变，所以对于每一个不同的字符串，都需要一个String对象来表示。这时，<font color="#0033ff">应该考虑使用StringBuffer类</font>，它允许修改，而不是每个不同的字符串都要生成一个新的对象。并且，这两种类的对象转换十分容易。<br />同时，我们还可以知道，如果要使用内容相同的字符串，不必每次都new一个String。例如我们要在构造器中对一个名叫s的String引用变量进行初始化，把它设置为初始值，应当这样做：<br />public class Demo {<br />private String s;<br />...<br />public Demo {<br />s = &quot;Initial Value&quot;;<br />}<br />...<br />}<br />而非<br />s = new String(&quot;Initial Value&quot;);<br />后者每次都会调用构造器，生成新对象，性能低下且内存开销大，并且没有意义，因为String对象不可改变，所以对于内容相同的字符串，只要一个String对象来表示就可以了。也就说，多次调用上面的构造器创建多个对象，他们的String类型属性s都指向同一个对象。<br />上面的结论还基于这样一个事实：对于字符串常量，如果内容相同，Java认为它们代表同一个String对象。而用关键字new调用构造器，总是会创建一个新的对象，无论内容是否相同。<br />至于为什么要把String类设计成不可变类，是它的用途决定的。其实不只String，很多Java标准类库中的类都是不可变的。在开发一个系统的时候，我们有时候也需要设计不可变类，来传递一组相关的值，这也是面向对象思想的体现。不可变类有一些优点，比如因为它的对象是只读的，所以多线程并发访问也不会有任何问题。当然也有一些缺点，比如每个不同的状态都要一个对象来代表，可能会造成性能上的问题。所以Java标准类库还提供了一个可变版本，即StringBuffer。<br /><br />问题四：final关键字到底修饰了什么？<br /><br />final使得被修饰的变量&quot;不变&quot;，但是由于对象型变量的本质是“引用”，使得“不变”也有了两种含义：<font color="#ff0000">引用本身的不变，和引用指向的对象不变</font>。<br /><br />引用本身的不变：<br />final StringBuffer a=new StringBuffer(&quot;immutable&quot;);<br />final StringBuffer b=new StringBuffer(&quot;not immutable&quot;);<br />a=b;//编译期错误<br /><br />引用指向的对象不变：<br />final StringBuffer a=new StringBuffer(&quot;immutable&quot;);<br />a.append(&quot; broken!&quot;); //编译通过<br /><br />可见，final只对引用的“值”(也即它所指向的那个对象的内存地址)有效，它迫使引用只能指向初始指向的那个对象，改变它的指向会导致编译期错误。至于<font color="#0033ff">它所指向的对象的变化，final是不负责的。</font>这很类似==操作符：==操作符只负责引用的“值”相等，至于这个地址所指向的对象内容是否相等，==操作符是不管的。<br /><br />理解final问题有很重要的含义。许多程序漏洞都基于此----<font color="#0000ff">final只能保证引用永远指向固定对象，不能保证那个对象的状态不变</font>。在多线程的操作中,一个对象会被多个线程共享或修改，一个线程对对象无意识的修改可能会导致另一个使用此对象的线程崩溃。一个错误的解决方法就是在此对象新建的时候把它声明为final，意图使得它“永远不变”。其实那是徒劳的。<br /><br />问题五：到底要怎么样初始化！<br /><br />本问题讨论变量的初始化，所以先来看一下Java中有哪些种类的变量。<br />1. 类的属性，或者叫值域<br />2. 方法里的局部变量<br />3. 方法的参数<br /><br />对于第一种变量，Java虚拟机会自动进行初始化。如果给出了初始值，则初始化为该初始值。如果没有给出，则把它初始化为该类型变量的默认初始值。<br /><br />int类型变量默认初始值为0<br />float类型变量默认初始值为0.0f<br />double类型变量默认初始值为0.0<br />boolean类型变量默认初始值为false<br />char类型变量默认初始值为0(ASCII码)<br />long类型变量默认初始值为0<br />所有对象引用类型变量默认初始值为null，即不指向任何对象。注意数组本身也是对象，所以没有初始化的数组引用在自动初始化后其值也是null。<br /><br />对于两种不同的类属性，static属性与instance属性，初始化的时机是不同的。<font color="#0000ff">instance属性在创建实例的时候初始化，static属性在类加载，也就是第一次用到这个类的时候初始化，对于后来的实例的创建，不再次进行初始化</font>。这个问题会在以后的系列中进行详细讨论。<br /><br />对于第二种变量，必须明确地进行初始化。如果再没有初始化之前就试图使用它，编译器会抗议。如果初始化的语句在try块中或if块中，也必须要让它在第一次使用前一定能够得到赋值。也就是说，把初始化语句放在只有if块的条件判断语句中编译器也会抗议，因为执行的时候可能不符合if后面的判断条件，如此一来初始化语句就不会被执行了，这就违反了局部变量使用前必须初始化的规定。但如果在else块中也有初始化语句，就可以通过编译，因为无论如何，总有至少一条初始化语句会被执行，不会发生使用前未被初始化的事情。对于try-catch也是一样，如果只有在try块里才有初始化语句，编译部通过。如果在catch或finally里也有，则可以通过编译。总之，要保证局部变量在使用之前一定被初始化了。所以，一个好的做法是在声明他们的时候就初始化他们，如果不知道要初始化成什么值好，就用上面的默认值吧！<br /><br />其实第三种变量和第二种本质上是一样的，都是方法中的局部变量。只不过作为参数，肯定是被初始化过的，传入的值就是初始值，所以不需要初始化。<br /><br />问题六：instanceof是什么东东？<br /><br />instanceof是Java的一个<font color="#ff0000">二元操作符</font>，和==，&gt;，&lt;是同一类东东。由于它是由字母组成的，所以也是Java的保留关键字。它的作用是<font color="#0000ff">测试它左边的对象是否是它右边的类的实例</font>，返回boolean类型的数据。举个例子：<br /><br />String s = &quot;I AM an Object!&quot;;<br />boolean isObject = s instanceof Object;<br /><br />我们声明了一个String对象引用，指向一个String对象，然后用instancof来测试它所指向的对象是否是Object类的一个实例，显然，这是真的，所以返回true，也就是isObject的值为True。<br />instanceof有一些用处。比如我们写了一个处理账单的系统，其中有这样三个类：<br /><br />public class Bill {//省略细节}<br />public class PhoneBill extends Bill {//省略细节}<br />public class GasBill extends Bill {//省略细节}<br /><br />在处理程序里有一个方法，接受一个Bill类型的对象，计算金额。假设两种账单计算方法不同，而传入的Bill对象可能是两种中的任何一种，所以要用instanceof来判断：<br /><br />public double calculate(Bill bill) {<br />if (bill instanceof PhoneBill) {<br />//计算电话账单<br />}<br />if (bill instanceof GasBill) {<br />//计算燃气账单<br />}<br />...<br />}<br />这样就可以用一个方法处理两种子类。<br /><br />然而，这种做法通常被认为是没有好好利用面向对象中的多态性。其实上面的功能要求用方法重载完全可以实现，这是面向对象变成应有的做法，避免回到结构化编程模式。只要提供两个名字和返回值都相同，接受参数类型不同的方法就可以了：<br /><br />public double calculate(PhoneBill bill) {<br />//计算电话账单<br />}<br /><br />public double calculate(GasBill bill) {<br />//计算燃气账单<br />}<br /><br />所以，使用instanceof在绝大多数情况下并不是推荐的做法，应当好好利用多态。<br /></font> 
					  </div> 
			    <p class="diaryFoot">- 作者： <a href="javascript:void(0);" onClick="window.open('http://publishblog.blogchina.com/blog/postMessage.b?receiver=413486','发送短消息','width=520, height=455')">youyou2005</a>  2005年07月26日, 星期二 20:20　
			    			    <a href="2395593.html#comment">回复（0）</a>
			     |　
			    <a href="2395593.html#trackback">引用（0）</a> 
			    <a href="javascript:void(keyit=window.open('http://blogmark.blogchina.com/jsp/key/quickaddkey.jsp?k='+encodeURI('每个java初学者都应该搞懂的问题！')+'&u='+encodeURI('http://youyou2005.blogchina.com/youyou2005/2395593.html')+'&c='+encodeURI(''),'keyit','scrollbars=no,width=500,height=430,status=no,resizable=yes'));keyit.focus();">加入博采</a></td>          
			    </p>
			  </div>
						
			  <div class="entity">
			    <h5 class="diaryTitle"><img src="http://blog.blogchina.com/template/common/img/array.gif"
 onclick="{if((document.getElementById('diary2279153')).style.display=='none') {(document.getElementById('diary2279153')).style.display='block'; this.src='http://blog.blogchina.com/template/common/img/array.gif'} else {(document.getElementById('diary2279153')).style.display='none'; this.src='http://blog.blogchina.com/template/common/img/array_2.gif'}}" class="imgShow">
			    <a href="2279153.html">
			    创建用于 ASP.NET 的分页程序控件[MSDN] </a>
			    			    </h5>
				<div id="diary2279153" style="display:block
				" class="diaryContent"> 
				      				      <p><b>摘要</b>：解决向任何 ASP.NET 控件添加分页功能的问题。还为开发复合 ASP.NET 控件提供了很多有用的提示和技巧。 </p><p><a href="http://download.microsoft.com/download/1/8/a/18a93b7c-aaaa-4fdc-a968-d56dad765849/MsdnSqlPagerSample.msi" target="_top">下载本文的源代码</a>（英文）。（请注意，在示例文件中，程序员的注释使用的是英文，本文中将其译为中文是为了便于读者理解。）</p><p>从程序员的角度来看，Microsoft&reg; SQL Server&#8482; 查询的最大缺陷之一就是返回的行数通常比应用程序的用户界面实际可以容纳的行数要多得多。这种尴尬情形经常将开发人员陷于困境。开发人员是应该创建一个非常长的页面，让用户花时间去滚动浏览，还是应该通过设置一个手动分页机制来更好地解决这个问题？ </p><p>哪种解决方案更好，在很大程度上取决于要检索的数据的特性。由多个项目（如搜索结果）组成的较长列表，最好通过各页大小相等、每页相对较短的多个页面显示。由单个项目（如文章的文本）组成的较长列表，如果整个插入在一个页面中，使用起来会更方便。最后得出的分析结果是，应该根据应用程序的总体用途来做决定。那么，Microsoft&reg; ASP.NET 是如何解决数据分页问题的呢？</p><p>ASP.NET 提供了功能强大的数据绑定控件，以便将查询结果格式化为 HTML 标记。但是，这些数据绑定控件中只有一种控件（即 <b>DataGrid</b> 控件）本来就支持分页。其他控件（如 <b>DataList</b>、<b>Repeater</b> 或 <b>CheckBoxList</b>）则不支持分页。这些控件及其他列表控件不支持分页，不是因为它们在结构上不支持分页，而是因为它们与 <b>DataGrid</b> 不同，不包含任何处理分页的特定代码。但是，处理分页的代码是相当样板化的，可以添加到所有这些控件中。 </p><p>Scott Mitchell 在最近的一篇题目为“<a href="http://msdn.microsoft.com/library/en-us/dnaspp/html/aspnet-pageablesortable.asp">Creating a Pageable, Sortable DataGrid</a>”（英文）的文章中，介绍了 <b>DataGrid</b> 分页。该文还引用了 Web 上的其他有用信息，为您提供了有关网格分页基础知识和其他信息。如果想查看如何使 <b>DataList</b> 控件可以进行分页的示例，可以查看<a href="https://www.aspnetpro.com/members/Login.asp?">此文章</a>（英文）。该文演示了如何创建一个自定义的 <b>DataList</b> 控件，该控件具有当前索引和页面大小属性，并可以启动页面更改事件。 </p><p>同样的代码也可以用于满足其他列表控件（如 <b>ListBox</b> 和 <b>CheckBoxList</b>）的分页需要。不过，向各个控件添加分页功能实际上并不是一种非常好的做法，因为，如上所述，分页代码是相当样板化的。因此，对于聪明的程序员来说，有什么方法比使用一种新的通用分页程序控件来实现所有这些控件的分页功能更好的呢？</p><p>本文中将建立一个分页程序控件，它将使合作者列表控件能够对 SQL Server 的查询结果进行分页。该控件名为 <b>SqlPager</b>，它支持两种类型的合作者控件 - 列表控件和基础数据列表控件。</p><p class="105v">SqlPager 控件的显著特点</p><p><b>SqlPager</b> 控件是一个 ASP.NET 复合控件，包含一个单行表格。该行又包含两个单元格 - 导航条和页面描述符。该控件的用户界面呈条形，理想情况下，其宽度与合作者控件的宽度相同。导航条部分提供了可单击的元素，以便在页面之间移动；页面描述符部分为用户提供了有关当前显示的页面的一些反馈信息。 </p><p class="fig"><img alt="" src="http://www.microsoft.com/china/msdn/Archives/library/dnaspp/images/pagercontrols_fig01.gif" border="0" /></p><p class="label"><b>图 1：Visual Studio .NET 网页设计器中显示的 SqlPager 控件</b></p><p>与 <b>DataGrid</b> 控件的嵌入式分页程序一样，<b>SqlPager</b> 控件具有两种导航模式，即下一页/上一页和数字页面。此外，其特殊属性 <b>PagerStyle</b> 使您能够选择更方便的样式。该控件与列表控件协同工作。您可以通过 <b>ControlToPaginate</b> 字符串属性为分页程序指定一个这样的合作者控件。 </p><pre class="code">SqlPager1.ControlToPaginate = &quot;ListBox1&quot;; 
        </pre><p>一般情况下，分页程序首先获取 SQL Server 的查询结果，准备一个适当的记录页面，然后通过合作者控件的 <b>DataSource</b> 属性显示该页面。当用户单击以查看新页面时，分页程序将检索请求的数据并再次通过合作者控件来显示数据。分页机制对于列表控件是完全透明的。列表控件的数据源是通过编程方式进行更新的，任何时候都只包含适合当前页面的记录。 </p><p>控件的分页引擎具有多个 public 属性，如 <b>CurrentPageIndex</b>、<b>ItemsPerPage</b> 和 <b>PageCount</b>，通过这些属性来获取并设置当前页面的索引、每个页面的大小以及要显示的页面的总数。分页程序管理数据检索和分页所需的任何逻辑。 </p><p><b>SelectCommand</b> 属性设置获取数据所用的命令文本。<b>ConnectionString</b> 属性定义数据库的名称和位置以及连接凭据。执行查询时采用的方式取决于 <b>PagingMode</b> 属性的值。该属性的可能值为与其同名的 <b>PagingMode</b> 枚举的值 - <b>Cached</b> 和 <b>NonCached</b>。如果选择 <b>Cached</b> 选项，则将使用数据适配器和 <b>DataTable</b> 对象检索整个结果集。可以选择将结果集放置在 ASP.NET 的 <b>Cache</b> 对象中，该结果集可以重复使用直到过期。如果选择 <b>NonCached</b> 选项，则查询只检索适合当前页面的记录。这时，ASP.NET 的 <b>Cache</b> 中不放置任何数据。<b>NonCached</b> 模式与 <b>DataGrid</b> 控件的自定义分页模式几乎相同。 </p><p>下表列出 <b>SqlPager</b> 控件的全部编程接口。</p><p class="label"><b>表 1：SqlPager 控件的编程接口</b></p><table class="data" cellspacing="0" bordercolordark="#ffffff" cellpadding="2" border="1"><tbody><tr valign="top" bgcolor="#cccccc"><th class="data" align="left" width="26%">名称</th><th class="data" align="left" width="13%">类型</th><th class="data" align="left" width="61%">说明</th></tr><tr valign="top"><td class="data" width="26%"><b>CacheDuration</b></td><td class="data" width="13%">属性</td><td class="data" width="61%">指示数据在 ASP.NET 的缓存中保留的秒数。只用于 <b>Cached</b> 模式。默认值为 60 秒。</td></tr><tr valign="top"><td class="data" width="26%"><b>ConnectionString</b></td><td class="data" width="13%">属性</td><td class="data" width="61%">用来访问所选择的 SQL Server 数据库的连接字符串。</td></tr><tr valign="top"><td class="data" width="26%"><b>ControlToPaginate</b></td><td class="data" width="13%">属性</td><td class="data" width="61%">同一个 .aspx 页面中的控件 ID，它将显示分页程序检索的记录页面。这是合作者控件。</td></tr><tr valign="top"><td class="data" width="26%"><b>CurrentPageIndex</b></td><td class="data" width="13%">属性</td><td class="data" width="61%">获取并设置基于 0 的页面索引。 </td></tr><tr valign="top"><td class="data" width="26%"><b>ItemsPerPage</b></td><td class="data" width="13%">属性</td><td class="data" width="61%">获取并设置每页要显示的记录数量。默认值为每页显示 10 个项目。</td></tr><tr valign="top"><td class="data" width="26%"><b>PagerStyle</b></td><td class="data" width="13%">属性</td><td class="data" width="61%">该值指示分页程序用户界面的样式。它可以为 PagerStyle 枚举值：<b>NextPrev</b> 和 <b>NumericPages</b> 之一。在 <b>NextPrev</b> 模式中，将显示 VCR 式的按钮，来转到第一页、上一页、下一页和最后一页。而在 <b>NumericPages</b> 模式中，将显示一个下拉列表，列出所有可用页面的索引。</td></tr><tr valign="top"><td class="data" width="26%"><b>PagingMode</b></td><td class="data" width="13%">属性</td><td class="data" width="61%">该值指示检索数据的方式。它可以为 PagingMode 枚举值：<b>Cached</b> 和 <b>NonCached</b> 之一。如果为 <b>Cached</b>，则将使用数据适配器，且整个结果集将临时放置在 ASP.NET 缓存中。如果为 <b>NonCached</b>，则只检索当前页面中的记录。在这种情况下，不进行缓存。</td></tr><tr valign="top"><td class="data" width="26%"><b>SelectCommand</b></td><td class="data" width="13%">属性</td><td class="data" width="61%">用来进行查询的命令文本。最好为 SELECT-FROM-WHERE 形式。不支持 ORDER BY 子句。排序是通过 <b>SortField</b> 属性另外指定的。</td></tr><tr valign="top"><td class="data" width="26%"><b>SortField</b></td><td class="data" width="13%">属性</td><td class="data" width="61%">用来排序的字段的名称。此字段用于为查询提供动态的 ORDER BY 子句。排序是由 SQL Server 执行的。 </td></tr><tr valign="top"><td class="data" width="26%"><b>ClearCache</b></td><td class="data" width="13%">方法</td><td class="data" width="61%">删除存储在 ASP.NET 缓存中的任何数据。</td></tr><tr valign="top"><td class="data" width="26%"><b>PageIndexChanged</b></td><td class="data" width="13%">事件</td><td class="data" width="61%">默认事件，当分页程序移动到另一个页面时发生。事件的数据结构为 <b>PageChangedEventArgs</b> 类，包含旧页面和新页面的索引。</td></tr></tbody></table><p>由于 <b>SqlPager</b> 控件继承了 <b>WebControl</b>，因此它也具有很多与 UI 相关的属性来管理字体、边框和颜色。 </p><p class="105v">生成 SqlPager 控件</p><p>将作为复合控件来生成 <b>SqlPager</b> 控件并让其继承 <b>WebControl</b> 类。复合控件是 ASP.NET 服务器控件所特有的，它是由一个或多个服务器控件组成。 </p><pre class="code">public class SqlPager : WebControl, INamingContainer
{ ... }
        </pre><p>除非生成完全自定义的控件或扩展现有的控件，否则，创建新控件时，大多数时间实际上是在生成复合控件。要创建 <b>SqlPager</b>，组合一个 <b>Table</b> 控件，并根据分页程序的样式，组合几个 <b>LinkButton</b> 控件或者一个 <b>DropDownList</b> 控件。 </p><p>生成复合控件时，需要注意几条原则。首先，需要覆盖 <b>CreateChildControls</b> protected 方法。<b>CreateChildControls</b> 方法是从 <b>Control</b> 继承来的，当服务器控件为了显示而要创建子控件时或在返回后，将调用此方法。 </p><pre class="code">protected override void CreateChildControls()
{
   // 清除现有的子控件及其 ViewState
   Controls.Clear();
   ClearChildViewState();

   // 生成控件树
   BuildControlHierarchy();
}
        </pre><p>覆盖此方法时，需要执行几项重要的操作。创建并初始化任何所需的子控件实例并将它们添加到父控件的 <b>Controls</b> 集合中。但是，生成新控件树之前，应该删除任何现有的子控件并清除子控件可能留下的任何 ViewState 信息。 </p><p>复合组件还需要实现 <b>INamingContainer</b> 接口，以便 ASP.NET 运行时可以为其创建一个新的命名范围。这就确保了复合控件中的所有控件都具有唯一的名称。这还将确保能够自动处理子控件的返回数据。 </p><p>对于 <b>SqlPager</b> 控件来说，成为命名容器非常重要。事实上，<b>SqlPager</b> 包含一些 <b>LinkButton</b> 控件，并且需要获取并处理其单击事件以便导航页面。正如 ASP.NET 页面中的任何其他控件一样，<b>LinkButton</b> 也被赋予了一个 ID，用于标识处理返回事件的控件。 </p><p>处理返回事件时，ASP.NET 运行时试图查找事件的目标 ID 与主窗体的任何直接子控件之间是否存在匹配关系。<b>LinkButton</b> 是分页程序的子控件，因此不能运行其服务器端的代码。这是否意味着只有窗体的直接子控件才能启动并处理服务器事件？当然不是，只要您使用命名容器。 </p><p>通过使 <b>SqlPager</b> 控件实现 <b>INamingContainer</b> 接口，可以将嵌入式链接按钮的实际 ID 从“First”更改为“SqlPager1:First”。当用户单击以查看新页面时，返回事件将 <b>SqlPager1:First</b> 作为目标控件。实际上，运行时用来识别目标控件的算法比上面介绍的要复杂一些。运行时将事件目标控件的名称看作是用冒号分隔开的字符串。实际上，这种匹配是在窗体的子控件和用冒号分隔开的字符串（如 <b>SqlPager1:First</b>）的第一个标记之间进行的。由于分页程序是窗体的子控件，因此匹配时会成功，分页程序获取单击事件。如果您认为这种解释不够充分或者令人费解，只要下载 <b>SqlPager</b> 控件的源代码，删除 <b>INamingContainer</b> 标记接口并进行重新编译即可。您将看到分页程序能够返回，但不能内部处理单击事件。</p><p><b>INamingContainer</b> 接口是一个不具备方法的标记接口，其实现只需在类声明中指定名称即可，无需进行任何其他操作。</p><p>复合控件的另一个重要方面是，它们通常不需要自定义逻辑来进行显示。复合控件的显示遵循其组成控件的显示。生成复合控件时，通常无需覆盖 <b>Render</b> 方法。 </p><p>控件的 <b>SqlPager</b> 树由一个包含两个单元格的单行表格组成。该表格继承了分页程序的大部分可视设置，如前景颜色和背景颜色、边框、字体信息和宽度等。第一个单元格包含导航条，其结构取决于 <b>PagerStyle</b> 属性的值。如果分页程序的样式为 NextPrev，则导航条将由四个 VCR 式的按钮组成。否则，它将由一个下拉列表组成。</p><pre class="code">private void BuildControlHierarchy()
{
   // 生成环境表格（一行，两个单元格）
   Table t = new Table();
   t.Font.Name = this.Font.Name;
   t.Font.Size = this.Font.Size;
   t.BorderStyle = this.BorderStyle;
   t.BorderWidth = this.BorderWidth;
   t.BorderColor = this.BorderColor;
   t.Width = this.Width;
   t.Height = this.Height;
   t.BackColor = this.BackColor;
   t.ForeColor = this.ForeColor;

   // 生成表格中的行
   TableRow row = new TableRow();
   t.Rows.Add(row);

   // 生成带有导航条的单元格
   TableCell cellNavBar = new TableCell();
   if (PagerStyle == this.PagerStyle.NextPrev)
      BuildNextPrevUI(cellNavBar);
   else
      BuildNumericPagesUI(cellNavBar);
   row.Cells.Add(cellNavBar);

   // 生成带有页面索引的单元格
   TableCell cellPageDesc = new TableCell();
   cellPageDesc.HorizontalAlign = HorizontalAlign.Right;
   BuildCurrentPage(cellPageDesc);
   row.Cells.Add(cellPageDesc);

   // 将表格添加到控件树
   this.Controls.Add(t);
}
        </pre><p>将各个控件添加到正确的 <b>Controls</b> 集合对于分页程序的正确显示极其重要。最外层的表格必须添加到分页程序的 <b>Controls</b> 集合中。链接按钮和下拉列表必须添加到相应表格单元格的 <b>Controls</b> 集合中。</p><p>下面给出了用来生成链接按钮导航条的代码。每个按钮都显示有一个 Webdings 字符，可以根据需要禁用，并被绑定到内部的 <b>Click</b> 事件处理程序。 </p><pre class="code">private void BuildNextPrevUI(TableCell cell)
{
   bool isValidPage = ((CurrentPageIndex &gt;=0) &amp;&amp; 
                      (CurrentPageIndex &lt;= TotalPages-1));
   bool canMoveBack = (CurrentPageIndex&gt;0);
   bool canMoveForward = (CurrentPageIndex&lt;TotalPages-1);

   // 显示 &lt;&lt; 按钮
   LinkButton first = new LinkButton();
   first.ID = &quot;First&quot;;
   first.Click += new EventHandler(first_Click);
   first.Font.Name = &quot;webdings&quot;;
   first.Font.Size = FontUnit.Medium;
   first.ForeColor = ForeColor;
   first.ToolTip = &quot;第一页&quot;;
   first.Text = &quot;7&quot;;   
   first.Enabled = isValidPage &amp;&amp; canMoveBack;
   cell.Controls.Add(first);
   :
}
        </pre><p>分页程序的另一种样式（在下拉列表中列出数字页面）的生成方法如下所示：</p><pre class="code">private void BuildNumericPagesUI(TableCell cell)
{
   // 显示一个下拉列表
   DropDownList pageList = new DropDownList();
   pageList.ID = &quot;PageList&quot;;
   pageList.AutoPostBack = true;
   pageList.SelectedIndexChanged += new EventHandler(PageList_Click);
   pageList.Font.Name = this.Font.Name;
   pageList.Font.Size = Font.Size;
   pageList.ForeColor = ForeColor;
   
   if (TotalPages &lt;=0 || CurrentPageIndex == -1)
   {
      pageList.Items.Add(&quot;No pages&quot;);
      pageList.Enabled = false;
      pageList.SelectedIndex = 0; 
   }
   else // 填充列表
   {
      for(int i=1; i&lt;=TotalPages; i++)
      {
         ListItem item = new ListItem(i.ToString(), (i-1).ToString());
         pageList.Items.Add(item);
      }
      pageList.SelectedIndex = CurrentPageIndex;
   }
}
        </pre><p>所有事件处理程序（Click 和 SelectedIndexChanged）最终都会更改当前显示的页面。这两种方法都会调用一个公用的 private 方法 <b>GoToPage</b>。</p><pre class="code">private void first_Click(object sender, EventArgs e)
{
   GoToPage(0);
}
private void PageList_Click(object sender, EventArgs e)
{
   DropDownList pageList = (DropDownList) sender;
   int pageIndex = Convert.ToInt32(pageList.SelectedItem.Value);
   GoToPage(pageIndex);
}
private void GoToPage(int pageIndex)
{
   // 准备事件数据
   PageChangedEventArgs e = new PageChangedEventArgs();
   e.OldPageIndex = CurrentPageIndex;
   e.NewPageIndex = pageIndex;

   // 更新当前的索引
   CurrentPageIndex = pageIndex;

   // 启动页面更改事件
   OnPageIndexChanged(e);

   // 绑定新数据
   DataBind();
}
        </pre><p>其他导航按钮的处理程序与 <b>first_Click</b> 的区别仅在于它们传递给 <b>GoToPage</b> 方法的页码不同。<b>GoToPage</b> 方法负责处理 <b>PageIndexChanged</b> 事件，并负责启动数据绑定过程。它准备事件数据（旧页面和新页面索引）并触发事件。<b>GoToPage</b> 被定义为 private，但是可以使用 <b>CurrentPageIndex</b> 属性通过编程的方式更改显示的页面。 </p><pre class="code">public int CurrentPageIndex
{
   get {return Convert.ToInt32(ViewState[&quot;CurrentPageIndex&quot;]);}
   set {ViewState[&quot;CurrentPageIndex&quot;] = value;}
}
        </pre><p>与表 1 中所列的所有属性一样，<b>CurrentPageIndex</b> 属性的实现方法也相当简单。它将其内容保存到 ViewState 中并从中进行还原。在数据绑定过程中，会验证和使用页面索引。</p><p class="105v">数据绑定过程</p><p><b>DataBind</b> 方法是所有 ASP.NET 控件公用的，对于数据绑定控件来说，它将触发用户界面的刷新以反映新数据。<b>SqlPager</b> 控件根据 <b>SelectCommand</b> 和 <b>ConnectionString</b> 属性的值，使用此方法启动数据检索操作。不言而喻，如果这些属性中的任何一个为空，该过程将终止。同样，如果合作者控件不存在，数据绑定过程将被取消。要查找合作者控件，<b>DataBind</b> 方法使用 <b>Page</b> 类中的 <b>FindControl</b> 函数。由此可见，合作者控件必须为主窗体的直接子控件。</p><p>进行分页显示的控件不能为任意的 ASP.NET 服务器控件。它必须为列表控件或基本数据列表控件。更一般来说，合作者控件必须具有 <b>DataSource</b> 属性并实现 <b>DataBind</b> 方法。可能进行分页的控件实际上只需要满足这些要求。Microsoft&reg; .NET Framework 中所有继承 <b>ListControl</b> 或 <b>BaseDataList</b> 的控件都满足第一个要求；而所有 Web 控件通过设计都满足 <b>DataBind</b> 要求。使用当前的实现方法，无法使用 <b>SqlPager</b> 控件来对 <b>Repeater</b> 进行分页。<b>Repeater</b> 与合作者控件 <b>DataList</b> 和 <b>DataGrid</b> 不同，不继承 <b>BaseDataList</b>，也不提供列表控件的功能。下表列出了可以使用 <b>SqlPager</b> 进行分页的控件。</p><p class="label"><b>表 2：可以由 SqlPager 控件进行分页的数据绑定控件 </b></p><table class="data" cellspacing="0" bordercolordark="#ffffff" cellpadding="2" border="1"><tbody><tr valign="top" bgcolor="#cccccc"><th class="data" align="left" width="22%">控件</th><th class="data" align="left" width="78%">说明</th></tr><tr valign="top"><td class="data" width="22%"><b>CheckBoxList</b></td><td class="data" width="78%">从 <b>ListControl</b> 派生而来，显示为复选框列表。 </td></tr><tr valign="top"><td class="data" width="22%"><b>DropDownList</b></td><td class="data" width="78%">从 <b>ListControl</b> 派生而来，显示为字符串下拉列表。</td></tr><tr valign="top"><td class="data" width="22%"><b>ListBox</b></td><td class="data" width="78%">从 <b>ListControl</b> 派生而来，显示为字符串可滚动列表。</td></tr><tr valign="top"><td class="data" width="22%"><b>RadioButtonList</b></td><td class="data" width="78%">从 <b>ListControl</b> 派生而来，显示为单选按钮列表。</td></tr><tr valign="top"><td class="data" width="22%"><b>DataList</b></td><td class="data" width="78%">从 <b>BaseDataList</b> 派生而来，显示为模板化数据项目列表。</td></tr><tr valign="top"><td class="data" width="22%"><b>DataGrid</b></td><td class="data" width="78%">从 <b>BaseDataList</b> 派生而来，显示为数据项目的表格网格。<b>DataGrid</b> 是唯一一个内置有功能强大的分页引擎的 ASP.NET 控件。 </td></tr></tbody></table><p>以下代码说明由 <b>SqlPager</b> 控件实现的数据绑定过程。 </p><pre class="code">public override void DataBind()
{
   // 启动数据绑定事件
   base.DataBinding();

   // 数据绑定后必须重新创建控件
   ChildControlsCreated = false;

   // 确保控件存在且为列表控件
   _controlToPaginate = Page.FindControl(ControlToPaginate);
   if (_controlToPaginate == null)
      return;
   if (!(_controlToPaginate is BaseDataList || 
         _controlToPaginate is ListControl))
      return;

   // 确保具有足够的连接信息并指定查询
   if (ConnectionString == &quot;&quot; || SelectCommand == &quot;&quot;)
      return;

   // 获取数据
   if (PagingMode == PagingMode.Cached)
      FetchAllData();
   else
      FetchPageData();

   // 将数据绑定到合作者控件
   BaseDataList baseDataListControl = null;
   ListControl listControl = null;
   if (_controlToPaginate is BaseDataList)
   {
       baseDataListControl = (BaseDataList) _controlToPaginate;
       baseDataListControl.DataSource = _dataSource; 
       baseDataListControl.DataBind();
       return;
   }
   if (_controlToPaginate is ListControl)
   {
       listControl = (ListControl) _controlToPaginate;
       listControl.Items.Clear(); 
       listControl.DataSource = _dataSource; 
       listControl.DataBind();
       return;
   }
}
        </pre><p>根据 <b>PagingMode</b> 属性的值调用不同的获取例程。在任何情况下，结果集都绑定到 <b>PagedDataSource</b> 类的实例上。此类提供了一些用来对数据进行分页的功能。特别是，当整个数据集都存储在缓存中时，该类将自动检索当前页面的记录并返回布尔值，来提供有关第一页和最后一页的信息。稍后将回来介绍此类的内部结构。在上述列表中，帮助程序的 <b>PagedDataSource</b> 对象是由 <b>_dataSource</b> 变量表示的。</p><p>然后，<b>SqlPager</b> 控件经过计算得出合作者控件的类型，并将 <b>PagedDataSource</b> 对象的内容绑定到合作者控件的 <b>DataSource</b> 属性。</p><p>有时，上述的 <b>DataBind</b> 方法还将 <b>ChildControlsCreated</b> 属性重新设置为 false。那么，为什么要这样做呢？ </p><p>当包含分页程序的页面返回时，所有控件都要重新创建；分页程序也不例外。通常情况下，所有控件及其子控件都是在准备显示页面之前创建的。在每个控件接收到 <b>OnPreRender</b> 通知之前的一瞬间，protected <b>EnsureChildControls</b> 方法将被调用，这样，每个控件都可以生成自己的控件树。此事件发生后，数据绑定过程完成，新数据已存储到缓存中。 </p><p>但是，当由于单击分页程序的一个组成控件而使页面返回时（即用户单击以更改页面），就会生成分页程序的控件树，这时远未达到显示阶段。特别是，当处理相关的服务器端事件时，就必须生成控件树，因而是在数据绑定开始之前生成控件树。困难在于，数据绑定将修改页面索引，而这必须反映在用户界面中。如果不采取某些对策的话，当用户切换到另一页时，分页程序中的页面索引将不会被刷新。</p><p>有各种方法可以解决此问题，但重要的是要弄清楚问题及其真正的原因。您可以避免生成控件树，并在 <b>Render</b> 方法中生成所有输出。另外，您还可以修改树中受数据绑定更改影响的部分。本文选择了第三种方法，这种方法需要较少的代码，而且，不管控件的用户界面的哪个部分受到数据绑定更改的影响，都能够解决问题。通过将 <b>ChildControlsCreated</b> 属性设置为 false，可以使以前创建的任何控件树无效。这样，在显示之前将重新创建控件树。</p><p class="105v">分页引擎</p><p><b>SqlPager</b> 控件支持两种检索数据的方法 - 缓存和非缓存。如果采用前者，选择命令原样执行，整个结果集将绑定到在内部进行分页的数据源对象上。<b>PagedDataSource</b> 对象将自动返回适合特定页面的记录。<b>PagedDataSource</b> 类也是在 <b>DataGrid</b> 默认分页机制背后运行的系统组件。</p><p>检索所有记录但只显示适合页面的几个记录，这通常不是一种明智的方法。由于 Web 应用程序的无状态特性，事实上，每次请求页面时都可能运行大量的查询。要使操作有效，采用缓存的数据检索方法必须依赖于某种缓存对象，ASP.NET 的 <b>Cache</b> 对象就是一个很好的候选对象。缓存技术的使用加快了应用程序的运行速度，但其提供的数据快照不能反映最新的更改。另外，它需要使用 Web 服务器上的较多内存。而且荒谬的是，如果大量的数据按会话缓存的话，甚至可能造成很大的问题。<b>Cache</b> 容器对于应用程序来说是全局的；如果数据按会话存储在其中，还需生成会话特有的项目名称。</p><p><b>Cache</b> 对象的上面是完全支持过期策略的。换句话说，存储在缓存中的数据在一段时间后可以自动被释放。以下代码说明 <b>SqlPager</b> 类中用来获取数据并将其存储在缓存中的一个 private 方法。</p><pre class="code">private void FetchAllData()
{
   // 在 ASP.NET Cache 中查找数据
   DataTable data;
   data = (DataTable) Page.Cache[CacheKeyName];
   if (data == null)
   {
      // 使用 order-by 信息修改 SelectCommand
      AdjustSelectCommand(true);

      // 如果数据过期或从未被获取，则转到数据库
      SqlDataAdapter adapter = new SqlDataAdapter(SelectCommand, 
            ConnectionString);
      data = new DataTable();
      adapter.Fill(data);
      Page.Cache.Insert(CacheKeyName, data, null, 
           DateTime.Now.AddSeconds(CacheDuration), 
           System.Web.Caching.Cache.NoSlidingExpiration);
   }
      
   // 配置分页的数据源组件
   if (_dataSource == null)
      _dataSource = new PagedDataSource(); 
   _dataSource.DataSource = data.DefaultView;  
   _dataSource.AllowPaging = true;
   _dataSource.PageSize = ItemsPerPage;
   TotalPages = _dataSource.PageCount; 

   // 确保页面索引有效
   ValidatePageIndex();
   if (CurrentPageIndex == -1)
   {
      _dataSource = null;
      return;
   }

   // 选择要查看的页面
   _dataSource.CurrentPageIndex = CurrentPageIndex;
}
        </pre><p>控件和请求的缓存项目名称是唯一的。它包括页面的 URL 和控件的 ID。在指定的时间（以秒计算）内，数据被绑定到缓存。要使项目过期，必须使用 <b>Cache.Insert</b> 方法。以下较简单的代码将项目添加到缓存，但不包括任何过期策略。</p><pre class="code">Page.Cache[CacheKeyName] = data;
        </pre><p><b>PagedDataSource</b> 对象通过其 <b>DataSource</b> 属性获取要进行分页的数据。值得注意的是，<b>PagedDataSource</b> 类的 <b>DataSource</b> 属性只接受 <b>IEnumerable</b> 对象。<b>DataTable</b> 不满足此要求，这就是为什么采取 <b>DefaultView</b> 属性的原因。</p><p><b>SelectCommand</b> 属性确定在 SQL Server 数据库上运行的查询。此字符串最好为 SELECT-FROM-WHERE 形式。不支持 ORDER BY 子句，如果指定了该子句，将被删除。这正是 <b>AdjustSelectCommand</b> 方法所做的。使用 <b>SortField</b> 属性可以指定任何排序信息。<b>AdjustSelectCommand</b> 方法本身将根据 <b>SortField</b> 的值添加一个正确的 ORDER BY 子句。这样做有什么原因吗？</p><p>当分页程序以 <b>NonCached</b> 模式工作时，原始的查询将被修改以确保只检索当前页面的记录。在 SQL Server 上执行的实际查询文本将采取以下形式。</p><pre class="code">SELECT * FROM 
(SELECT TOP <code><b class="cfe">ItemsPerPage </b></code>* FROM 
(SELECT TOP <code><b class="cfe">ItemsPerPage*CurrentPageIndex </b></code>* FROM 
(<code><b class="cfe">SelectCommand</b></code>) AS t0 
ORDER BY <code><b class="cfe">SortField </b></code>ASC) AS t1
ORDER BY <code><b class="cfe">SortField</b></code> DESC) AS t2 
ORDER BY <code><b class="cfe">SortField</b></code>
        </pre><p>该查询弥补了 SQL Server 2000 中 ROWNUM 子句的缺陷，并且对记录进行重新排序，使得只有 <i>x</i> 项目的“第 n 个”块经过正确排序后返回。您可以指定基础查询，分页程序将它分解为多个较小的页面。只有适合某个页面的记录被返回。正如您看到的那样，除了查询命令以外，上述查询需要处理排序字段。这就是为什么另外添加了 <b>SortField</b> 属性。此代码的唯一缺陷是默认情况为升序排序。通过使 ASC/DESC 关键字参数化，可以使此代码真的非常完美：</p><pre class="code">private void FetchPageData()
{
   // 需要经过验证的页面索引来获取数据。
   // 还需要实际的页数来验证页面索引。
   AdjustSelectCommand(false);
   VirtualRecordCount countInfo = CalculateVirtualRecordCount();
   TotalPages = countInfo.PageCount;

   // 验证页码（确保 CurrentPageIndex 有效或为“-1”）
   ValidatePageIndex();
   if (CurrentPageIndex == -1)
      return;

   // 准备并运行命令
   SqlCommand cmd = PrepareCommand(countInfo);
   if (cmd == null)
      return;
   SqlDataAdapter adapter = new SqlDataAdapter(cmd);
   DataTable data = new DataTable();
   adapter.Fill(data);

   // 配置分页的数据源组件
   if (_dataSource == null)
      _dataSource = new PagedDataSource(); 
   _dataSource.AllowCustomPaging = true;
   _dataSource.AllowPaging = true;
   _dataSource.CurrentPageIndex = 0;
   _dataSource.PageSize = ItemsPerPage;
   _dataSource.VirtualCount = countInfo.RecordCount;
   _dataSource.DataSource = data.DefaultView;   
}
        </pre><p>在 <b>NonCached</b> 模式中，<b>PagedDataSource</b> 对象并不提供整个数据源，因此不能计算出要进行分页的总页数。进而必须对 <b>AllowCustomPaging</b> 属性进行标记，并提供数据源中的实际记录数量。通常，实际数量是使用 SELECT COUNT(*) 查询进行检索的。此模型与 <b>DataGrid</b> 的自定义分页几乎相同。此外，<b>PagedDataSource</b> 对象中选择的当前页面索引通常为 0，因为实际上已经存储了一页记录。</p><p><b>SqlPager</b> 控件的实现方法就介绍到这里，下面我们介绍一下它的使用方法。</p><p class="105v">使用 SqlPager 控件</p><p>假设存在一个包含 <b>ListBox</b> 控件的示例页面。要使用分页程序，请确保 .aspx 页面正确地注册了该控件的程序集。 </p><pre class="code">&lt;%@ Register TagPrefix=&quot;expo&quot; Namespace=&quot;DevCenter&quot; Assembly=&quot;SqlPager&quot; %&gt;
        </pre><p>控件的标记取决于实际设置的属性。以下标记是一个合理的示例：</p><pre class="code">&lt;asp:listbox runat=&quot;server&quot; id=&quot;ListBox1&quot; 
     Width=&quot;300px&quot; Height=&quot;168px&quot;
     DataTextField=&quot;companyname&quot; /&gt; 
&lt;br&gt;
&lt;expo:SqlPager runat=&quot;server&quot; id=&quot;SqlPager1&quot; Width=&quot;300px&quot; 
   ControlToPaginate=&quot;ListBox1&quot; 
   SelectCommand=&quot;SELECT customerid, companyname FROM customers&quot; 
      ConnectionString=&quot;SERVER=localhost;DATABASE=northwind;UID=...&quot;
      SortKeyField=&quot;companyname&quot; /&gt;
&lt;br&gt;
&lt;asp:button runat=&quot;server&quot; id=&quot;LoadFirst1&quot; Text=&quot;加载第一页&quot; /&gt; 
        </pre><p>除了分页程序以外，页面还包含一个<b>列表框</b>和一个按钮。<b>列表框</b>将显示每个页面的内容；按钮只用于首次填充<b>列表框</b>。该按钮具有一个单击事件处理程序，定义如下。</p><pre class="code">private void LoadFirst1_Click(object sender, EventArgs e) {
   SqlPager1.CurrentPageIndex = 0;
   SqlPager1.DataBind(); 
}
        </pre><p>图 2 显示操作中的页面。</p><p class="fig"><img alt="" src="http://www.microsoft.com/china/msdn/Archives/library/dnaspp/images/pagercontrols_fig02.gif" border="0" /></p><p class="label"><b>图 2：与 ListBox 控件协同工作的 SqlPager 控件。</b></p><p>使用 <b>DataList</b> 控件可以生成一个更有意思的示例。目标是使用分页程序浏览每个 Northwind 职员的个人记录。该 <b>DataList</b> 如以下列表所示。</p><pre class="code">&lt;asp:datalist runat=&quot;server&quot; id=&quot;DataList1&quot; Width=&quot;300px&quot; 
     Font-Names=&quot;Verdana&quot; Font-Size=&quot;8pt&quot;&gt;
&lt;ItemTemplate&gt;
&lt;table bgcolor=&quot;#f0f0f0&quot; style=&quot;font-family:verdana;font-size:8pt;&quot;&gt;
  &lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
      &lt;b&gt;&lt;%# DataBinder.Eval(Container.DataItem, &quot;LastName&quot;) + &quot;, &quot; + 
      DataBinder.Eval(Container.DataItem, &quot;firstname&quot;) %&gt;&lt;/b&gt;&lt;/td&gt;&lt;/tr&gt;
  
  &lt;tr&gt;&lt;td&gt;
      &lt;span style=&quot;color:blue;&quot;&gt;&lt;i&gt;
      &lt;%# DataBinder.Eval(Container.DataItem, &quot;Title&quot;)%&gt;&lt;/i&gt;&lt;/span&gt;
      &lt;p&gt;&lt;img style=&quot;float:right;&quot; src='image.aspx?
          id=&lt;%# DataBinder.Eval(Container.DataItem, &quot;employeeid&quot;)%&gt;' /&gt;
      &lt;%# DataBinder.Eval(Container.DataItem, &quot;Notes&quot;) %&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;/ItemTemplate&gt;
&lt;/asp:datalist&gt;
        </pre><p>表格的第一行显示职员的姓名和职务，然后是相片，相片周围是注释。相片是使用特定的 .aspx 页面检索的，返回从数据库中获取的 JPEG 数据。 </p><p>分页程序可以放置在页面中的任何位置。本例中将它放置在合作者 <b>DataList</b> 控件上方并紧挨着合作者控件。</p><p class="fig"><img alt="" src="http://www.microsoft.com/china/msdn/Archives/library/dnaspp/images/pagercontrols_fig03.gif" border="0" /></p><p class="label"><b>图 3：SqlPager 对 DataList 控件进行分页 </b></p><p>将 <b>SqlPager</b> 控件与 <b>DataGrid</b> 控件一起使用有意义吗？这要视情况而定。<b>DataGrid</b> 已经与一个基于本文中使用的 <b>PagedDataSource</b> 对象的嵌入式分页引擎一起工作。因此，如果您需要对以表格格式显示的单个记录集合进行分页时，就无需使用 <b>SqlPager</b>。但是，对于重要/复杂的方案，将这两个控件一起使用并不是一种牵强的想法。例如，如果您要向前一个屏幕快照添加一个 <b>DataGrid</b> 来显示由职员管理的订单，则可以在同一格页面上放置两个相关的分页引擎，一个要对职员进行分页，另一个用于滚动相关订单。</p><p class="105v">小结</p><p>不管您要生成哪种类型的应用程序（Web 应用程序、Microsoft&reg; Windows&reg; 应用程序或 Web 服务），您都很难下载和缓存要显示的整个数据源。有时，测试环境会使您相信这种解决方案真是太棒了，非常可取。但是测试环境也会误导。数据源的大小非常关键，应用程序的规模越大，数据源的大小越关键。</p><p>在 ASP.NET 中，只有 <b>DataGrid</b> 控件具有内置的分页功能。但是，分页引擎是由相当样板化的代码实现的，只要进行少量的处理，就可以进行推广并用于多个不同的控件。本文介绍的 <b>SqlPager</b> 控件就实现了此目标。它关注下载数据，将数据分成多个页面并通过合作者控件显示。该控件可以检索并缓存整个数据集，或者仅在 SQL Server 中查询要在选定的页面中显示的几个记录。我说的是 SQL Server，这是另一个重点。<b>SqlPager</b> 只能用于 SQL Server，不能用于通过 OLE DB 或 ODBC 来检索数据。也不能使用它访问 Oracle 或 DB2 存档。 </p><p>要生成真正的通用 SQL 分页程序组件，应该形成数据访问层，并生成一种能够使用相应的数据提供程序创建连接、命令和适配器的工厂类。此外，要注意为各种 SQL 源设置一个分页引擎是最糟糕的做法。这里介绍的方法只适用于 SQL Server 7.0 和更高版本。<b>TOP</b> 子句在不同的环境下具有不同的特性。使用服务器游标和临时表格，它可适用于较大范围的 DBMS 系统。但那将使代码更为复杂。</p> 
					  </div> 
			    <p class="diaryFoot">- 作者： <a href="javascript:void(0);" onClick="window.open('http://publishblog.blogchina.com/blog/postMessage.b?receiver=413486','发送短消息','width=520, height=455')">youyou2005</a>  2005年07月15日, 星期五 13:30　
			    			    <a href="2279153.html#comment">回复（0）</a>
			     |　
			    <a href="2279153.html#trackback">引用（0）</a> 
			    <a href="javascript:void(keyit=window.open('http://blogmark.blogchina.com/jsp/key/quickaddkey.jsp?k='+encodeURI('创建用于 ASP.NET 的分页程序控件[MSDN] ')+'&u='+encodeURI('http://youyou2005.blogchina.com/youyou2005/2279153.html')+'&c='+encodeURI(''),'keyit','scrollbars=no,width=500,height=430,status=no,resizable=yes'));keyit.focus();">加入博采</a></td>          
			    </p>
			  </div>
						
			  <div class="entity">
			    <h5 class="diaryTitle"><img src="http://blog.blogchina.com/template/common/img/array.gif"
 onclick="{if((document.getElementById('diary2243654')).style.display=='none') {(document.getElementById('diary2243654')).style.display='block'; this.src='http://blog.blogchina.com/template/common/img/array.gif'} else {(document.getElementById('diary2243654')).style.display='none'; this.src='http://blog.blogchina.com/template/common/img/array_2.gif'}}" class="imgShow">
			    <a href="2243654.html">
			    初学者如何开发出一个高质量的J2EE系统 </a>
			    			    </h5>
				<div id="diary2243654" style="display:block
				" class="diaryContent"> 
				      				      <p>J2EE学习者越来越多，J2EE本身技术不断在发展，涌现出各种概念，本文章试图从一种容易理解的角度对这些概念向初学者进行解释，以便掌握学习J2EE学习方向。</p><p>　　首先我们需要知道Java和J2EE是两个不同概念，Java不只是指一种语言，已经代表与微软不同的另外一个巨大阵营，所以Java有时是指一种软件系统的流派，当然目前主要是.NET和Java两大主流体系。</p><p>　　J2EE可以说指Java在数据库信息系统上实现，数据库信息系统从早期的dBase、到Delphi/VB等C/S结构，发展到B/S（Browser浏览器/Server服务器）结构，而J2EE主要是指B/S结构的实现。</p><p>　　J2EE又是一种框架和标准，框架类似API、库的概念，但是要超出它们。如果需要详细了解框架，可先从<a href="http://www.jdon.com/designpatterns/index.htm" target="_blank">设计模式</a>开始学习。</p><p>　　J2EE是一个虚的大的概念，J2EE标准主要有三种子技术标准：WEB技术、EJB技术和JMS，谈到J2EE应该说最终要落实到这三个子概念上。</p><p>　　这三种技术的每个技术在应用时都涉及两个部分：容器部分和应用部分，Web容器也是指Jsp/Servlet容器，你如果要开发一个Web应用，无论是编译或运行，都必须要有Jsp/Servlet库或API支持（除了JDK/J2SE以外）。</p><p>　　Web技术中除了Jsp/Servlet技术外，还需要JavaBeans或Java Class实现一些功能或者包装携带数据，所以Web技术最初裸体简称为Jsp/Servlet+JavaBeans系统。</p><p>　　谈到JavaBeans技术，就涉及到组件构件技术（component），这是Java的核心基础部分，很多软件设计概念（设计模式）都是通过JavaBeans实现的。</p><p>　　JavaBeans不属于J2EE概念范畴中，如果一个JavaBeans对象被Web技术（也就是Jsp/Servlet）调用，那么JavaBeans就运行在J2EE的Web容器中；如果它被EJB调用，它就运行在EJB容器中。</p><p>　　EJB（企业JavaBeans）是普通JavaBeans的一种提升和规范，因为企业信息系统开发中需要一个可伸缩的性能和事务、安全机制，这样能保证企业系统平滑发展，而不是发展到一种规模重新更换一套软件系统。</p><p>　　至此，JavaBeans组件发展到EJB后，并不是说以前的那种JavaBeans形式就消失了，这就自然形成了两种JavaBeans技术：EJB和POJO，POJO完全不同于EJB概念，指的是普通JavaBeans，而且这个JavaBeans不依附某种框架，或者干脆可以说：这个JavaBeans是你为这个应用程序单独开发创建的。</p><p>　　J2EE应用系统开发工具有很多：如JBuilder、Eclipse等，这些IDE首先是Java开发工具，也就是说，它们首要基本功能是可以开发出JavaBeans或Java class，但是如果要开发出J2EE系统，就要落实到要么是Web技术或EJB技术，那么就有可能要一些专门模块功能(如eclipse需要lomboz插件)，最重要的是，因为J2EE系统区分为容器和应用两个部分，所以，在任何开发工具中开发J2EE都需要指定J2EE容器。</p><p>　　J2EE容器分为WEB容器和EJB容器，Tomcat/Resin是Web容器；JBoss是EJB容器+Web容器等，其中Web容器直接使用Tomcat实现的。所以你开发的Web应用程序可以在上面两种容器运行，而你开发的Web+EJB应用则只可以在JBoss服务器上运行，商业产品Websphere/Weblogic等和JBoss属于同一种性质。</p><p>　　J2EE容器也称为J2EE服务器，大部分时它们概念是一致的。</p><p>　　如果你的J2EE应用系统的数据库连接是通过JNDI获得，也就是说是从容器中获得，那么你的J2EE应用系统基本与数据库无关，如果你在你的J2EE应用系统耦合了数据库JDBC驱动的配置，那么你的J2EE应用系统就有数据库概念色彩，作为一个成熟需要推广的J2EE应用系统，不推荐和具体数据库耦合，当然这其中如何保证J2EE应用系统运行性能又是体现你的设计水平了。</p><p>　　衡量J2EE应用系统设计开发水平高低的标准就是：解耦性；你的应用系统各个功能是否能够彻底脱离？是否不相互依赖，也只有这样，才能体现可维护性、可拓展性的软件设计目标。</p><p>　　为了达到这个目的，诞生各种框架概念，J2EE框架标准将一个系统划分为WEB和EJB主要部分，当然我们有时不是以这个具体技术区分，而是从设计上抽象为表现层、服务层和持久层，这三个层次从一个高度将J2EE分离开来，实现解耦目的。</p><p>　　因此，我们实际编程中，也要将自己的功能向这三个层次上靠，做到大方向清楚，泾渭分明，但是没有技术上约束限制要做到这点是很不容易的，因此我们还是必须借助J2EE具体技术来实现，这时，你可以使用EJB规范实现服务层和持久层，Web技术实现表现层；</p><p>　　EJB为什么能将服务层从Jsp/Servlet手中分离出来，因为它对JavaBeans编码有强制的约束，现在有一种对JavaBeans弱约束，使用Ioc模式实现的（当然EJB 3.0也采取这种方式），在Ioc模式诞生前，一般都是通过工厂模式来对JavaBeans约束，形成一个服务层，这也是是Jive这样开源论坛设计原理之一。</p><p>　　由此，将服务层从表现层中分离出来目前有两种可选架构选择：管理普通JavaBeans（POJO）框架(如Spring、<a href="http://www.jdon.com/jdonframework/index.htm" target="_blank">JdonFramework</a>)以及管理EJB的EJB框架，因为EJB不只是框架，还是标准，而标准可以扩展发展，所以，这两种区别将来是可能模糊，被纳入同一个标准了。　但是，个人认为：标准制定是为某个目的服务的，总要牺牲一些换取另外一些，所以，这两种架构会长时间并存。</p><p>　　这两种架构分歧也曾经诞生一个新名词：完全POJO的系统也称为轻量级系统(lightweight)，其实这个名词本身就没有一个严格定义，更多是一个吸引人的招牌，轻量是指容易学习容易使用吗？按照这个定义，其实轻量Spring等系统并不容易学习；而且EJB 3.0（依然叫EJB）以后的系统是否可称为轻量级了呢？</p><p>　　前面谈了服务层框架，使用服务层框架可以将JavaBeans从Jsp/Servlet中分离出来，而使用表现层框架则可以将Jsp中剩余的JavaBeans完全分离，这部分JavaBeans主要负责显示相关，一般是通过标签库（taglib）实现，不同框架有不同自己的标签库，Struts是应用比较广泛的一种表现层框架。</p><p>　　这样，表现层和服务层的分离是通过两种框架达到目的，剩余的就是持久层框架了，通过持久层的框架将数据库存储从服务层中分离出来是其目的，持久层框架有两种方向：直接自己编写JDBC等SQL语句（如iBatis）；使用O/R Mapping技术实现的Hibernate和JDO技术；当然还有EJB中的实体Bean技术。</p><p>　　持久层框架目前呈现百花齐放，各有优缺点的现状，所以正如表现层框架一样，目前没有一个框架被指定为标准框架，当然，表现层框架现在又出来了一个JSF，它代表的页面组件概念是一个新的发展方向，但是复杂的实现让人有些忘而却步。</p><p>　　在所有这些J2EE技术中，虽然SUN公司发挥了很大的作用，不过总体来说：网络上有这样一个评价：SUN的理论天下无敌；SUN的产品用起来撞墙；对于初学者，特别是那些试图通过或已经通过SUN认证的初学者，赶快摆脱SUN的阴影，立即开溜，使用开源领域的产品来实现自己的应用系统。</p><p>　　最后，你的J2EE应用系统如果采取上面提到的表现层、服务层和持久层的框架实现，基本你也可以在无需深刻掌握设计模式的情况下开发出一个高质量的应用系统了。</p><p>　　还要注意的是: 开发出一个高质量的J2EE系统还需要正确的业务需求理解，那么域建模提供了一种比较切实可行的正确理解业务需求的方法，相关详细知识可从UML角度结合理解。</p><p>　　当然，如果你想设计自己的行业框架，那么第一步从设计模式开始吧，因为设计模式提供你一个实现JavaBeans或类之间解耦参考实现方法，当你学会了系统基本单元JavaBean或类之间解耦时，那么系统模块之间的解耦你就可能掌握，进而你就可以实现行业框架的提炼了，这又是另外一个发展方向了。</p><p>　　以上理念可以总结为一句话：<br />J2EE开发三件宝: Domain Model（域建模）、patterns（模式）和framework（框架）。<br /></p> 
					  </div> 
			    <p class="diaryFoot">- 作者： <a href="javascript:void(0);" onClick="window.open('http://publishblog.blogchina.com/blog/postMessage.b?receiver=413486','发送短消息','width=520, height=455')">youyou2005</a>  2005年07月12日, 星期二 14:27　
			    			    <a href="2243654.html#comment">回复（0）</a>
			     |　
			    <a href="2243654.html#trackback">引用（0）</a> 
			    <a href="javascript:void(keyit=window.open('http://blogmark.blogchina.com/jsp/key/quickaddkey.jsp?k='+encodeURI('初学者如何开发出一个高质量的J2EE系统 ')+'&u='+encodeURI('http://youyou2005.blogchina.com/youyou2005/2243654.html')+'&c='+encodeURI(''),'keyit','scrollbars=no,width=500,height=430,status=no,resizable=yes'));keyit.focus();">加入博采</a></td>          
			    </p>
			  </div>
						
			  <div class="entity">
			    <h5 class="diaryTitle"><img src="http://blog.blogchina.com/template/common/img/array.gif"
 onclick="{if((document.getElementById('diary2207126')).style.display=='none') {(document.getElementById('diary2207126')).style.display='block'; this.src='http://blog.blogchina.com/template/common/img/array.gif'} else {(document.getElementById('diary2207126')).style.display='none'; this.src='http://blog.blogchina.com/template/common/img/array_2.gif'}}" class="imgShow">
			    <a href="2207126.html">
			    JSP页面连接数据库大全</a>
			    			    </h5>
				<div id="diary2207126" style="display:block
				" class="diaryContent"> 
				      				      <div class="postTitle"><a href="http://blog.csdn.net/narilee/archive/2005/07/08/417216.aspx">JSP页面连接数据库大全</a></div><div class="postTitle">许多初学jsp的网友经常会问数据库怎么连接啊，我总结一下供大家参考，<br />其实这种把数据库逻辑全部放在jsp里未必是好的做法，但是有利于初学者学习，当大家学到一定程度的时候，<br />可以考虑用MVC的模式开发。在练习这些代码的时候，你一定将jdbc的驱动程序放到服务器的类路径里，<br />然后要在数据库里建一个表test,有两个字段比如为test1，test2，可以用下面SQL建 <br />create table test(test1 varchar(20),test2 varchar(20) <br />然后向这个表写入一条测试纪录，那么现在开始我们的jsp和数据库之旅吧。 </div><div class="postText"><p><strong>一、jsp连接Oracle8/8i/9i数据库（用thin模式） <br /></strong>testoracle.jsp如下： <br />&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt; <br />&lt;%@ page import=&quot;java.sql.*&quot;%&gt; <br />&lt;html&gt; <br />&lt;body&gt; <br />&lt;%Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;).newInstance(); <br />String url=&quot;jdbc:oracle:thin:@localhost:1521:orcl&quot;; <br />//orcl为你的数据库的SID <br />String user=&quot;scott&quot;; <br />String password=&quot;tiger&quot;; <br />Connection conn= DriverManager.getConnection(url,user,password); <br />Statement stmt=conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_UPDATABLE); <br />String sql=&quot;select * from test&quot;; <br />ResultSet rs=stmt.executeQuery(sql); <br />while(rs.next()) {%&gt; <br />您的第一个字段内容为：&lt;%=rs.getString(1)%&gt; <br />您的第二个字段内容为：&lt;%=rs.getString(2)%&gt; <br />&lt;%}%&gt; <br />&lt;%out.print(&quot;数据库操作成功，恭喜你&quot;);%&gt; <br />&lt;%rs.close(); <br />stmt.close(); <br />conn.close(); <br />%&gt; <br />&lt;/body&gt; <br />&lt;/html&gt; </p><p><strong>二、jsp连接Sql Server7.0/2000数据库</strong> <br />testsqlserver.jsp如下： <br />&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt; <br />&lt;%@ page import=&quot;java.sql.*&quot;%&gt; <br />&lt;html&gt; <br />&lt;body&gt; <br />&lt;%Class.forName(&quot;com.microsoft.jdbc.sqlserver.SQLServerDriver&quot;).newInstance(); <br />String url=&quot;jdbc:microsoft:sqlserver://localhost:1433;DatabaseName=pubs&quot;; <br />//pubs为你的数据库的 <br />String user=&quot;sa&quot;; <br />String password=&quot;&quot;; </p><p>Connection conn= DriverManager.getConnection(url,user,password); <br />Statement stmt=conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_UPDATABLE); <br />String sql=&quot;select * from test&quot;; <br />ResultSet rs=stmt.executeQuery(sql); <br />while(rs.next()) {%&gt; <br />您的第一个字段内容为：&lt;%=rs.getString(1)%&gt; <br />您的第二个字段内容为：&lt;%=rs.getString(2)%&gt; <br />&lt;%}%&gt; <br />&lt;%out.print(&quot;数据库操作成功，恭喜你&quot;);%&gt; <br />&lt;%rs.close(); <br />stmt.close(); <br />conn.close(); </p><p>%&gt; <br />&lt;/body&gt; <br />&lt;/html&gt; </p><p><strong>三、jsp连接DB2数据库</strong> <br />testdb2.jsp如下： <br />&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt; <br />&lt;%@ page import=&quot;java.sql.*&quot;%&gt; <br />&lt;html&gt; <br />&lt;body&gt; <br />&lt;%Class.forName(&quot;com.ibm.db2.jdbc.app.DB2Driver &quot;).newInstance(); <br />String url=&quot;jdbc:db2://localhost:5000/sample&quot;; <br />//sample为你的数据库名 <br />String user=&quot;admin&quot;; <br />String password=&quot;&quot;; <br />Connection conn= DriverManager.getConnection(url,user,password); <br />Statement stmt=conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_UPDATABLE); <br />String sql=&quot;select * from test&quot;; <br />ResultSet rs=stmt.executeQuery(sql); <br />while(rs.next()) {%&gt; <br />您的第一个字段内容为：&lt;%=rs.getString(1)%&gt; <br />您的第二个字段内容为：&lt;%=rs.getString(2)%&gt; <br />&lt;%}%&gt; <br />&lt;%out.print(&quot;数据库操作成功，恭喜你&quot;);%&gt; <br />&lt;%rs.close(); <br />stmt.close(); <br />conn.close(); <br />%&gt; <br />&lt;/body&gt; <br />&lt;/html&gt; <br /><strong>四、jsp连接Informix数据库 <br /></strong>testinformix.jsp如下： <br />&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt; <br />&lt;%@ page import=&quot;java.sql.*&quot;%&gt; <br />&lt;html&gt; <br />&lt;body&gt; <br />&lt;%Class.forName(&quot;com.informix.jdbc.IfxDriver&quot;).newInstance(); <br />String url = <br />&quot;jdbc:informix-sqli://123.45.67.89:1533/testDB:INFORMIXSERVER=myserver; <br />user=testuser;password=testpassword&quot;; <br />//testDB为你的数据库名 <br />Connection conn= DriverManager.getConnection(url); <br />Statement stmt=conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_UPDATABLE); <br />String sql=&quot;select * from test&quot;; <br />ResultSet rs=stmt.executeQuery(sql); <br />while(rs.next()) {%&gt; <br />您的第一个字段内容为：&lt;%=rs.getString(1)%&gt; <br />您的第二个字段内容为：&lt;%=rs.getString(2)%&gt; <br />&lt;%}%&gt; <br />&lt;%out.print(&quot;数据库操作成功，恭喜你&quot;);%&gt; <br />&lt;%rs.close(); <br />stmt.close(); <br />conn.close(); <br />%&gt; <br />&lt;/body&gt; <br />&lt;/html&gt; </p><p><strong>五、jsp连接Sybase数据库</strong> <br />testmysql.jsp如下： <br />&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt; <br />&lt;%@ page import=&quot;java.sql.*&quot;%&gt; <br />&lt;html&gt; <br />&lt;body&gt; <br />&lt;%Class.forName(&quot;com.sybase.jdbc.SybDriver&quot;).newInstance(); <br />String url =&quot; jdbc:sybase:Tds:localhost:5007/tsdata&quot;; <br />//tsdata为你的数据库名 <br />Properties sysProps = System.getProperties(); <br />SysProps.put(&quot;user&quot;,&quot;userid&quot;); <br />SysProps.put(&quot;password&quot;,&quot;user_password&quot;); <br />Connection conn= DriverManager.getConnection(url, SysProps); <br />Statement stmt=conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_UPDATABLE); <br />String sql=&quot;select * from test&quot;; <br />ResultSet rs=stmt.executeQuery(sql); <br />while(rs.next()) {%&gt; <br />您的第一个字段内容为：&lt;%=rs.getString(1)%&gt; <br />您的第二个字段内容为：&lt;%=rs.getString(2)%&gt; <br />&lt;%}%&gt; <br />&lt;%out.print(&quot;数据库操作成功，恭喜你&quot;);%&gt; <br />&lt;%rs.close(); <br />stmt.close(); <br />conn.close(); <br />%&gt; <br />&lt;/body&gt; <br />&lt;/html&gt; </p><p><strong>六、jsp连接MySQL数据库</strong> <br />testmysql.jsp如下： <br />&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt; <br />&lt;%@ page import=&quot;java.sql.*&quot;%&gt; <br />&lt;html&gt; <br />&lt;body&gt; <br />&lt;%Class.forName(&quot;org.gjt.mm.mysql.Driver&quot;).newInstance(); <br />String url =&quot;jdbc:mysql://localhost/softforum?user=soft&amp;password=soft1234&amp;useUnicode=true&amp;characterEncoding=8859_1&quot; <br />//testDB为你的数据库名 <br />Connection conn= DriverManager.getConnection(url); <br />Statement stmt=conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_UPDATABLE); <br />String sql=&quot;select * from test&quot;; <br />ResultSet rs=stmt.executeQuery(sql); <br />while(rs.next()) {%&gt; <br />您的第一个字段内容为：&lt;%=rs.getString(1)%&gt; <br />您的第二个字段内容为：&lt;%=rs.getString(2)%&gt; <br />&lt;%}%&gt; <br />&lt;%out.print(&quot;数据库操作成功，恭喜你&quot;);%&gt; <br />&lt;%rs.close(); <br />stmt.close(); <br />conn.close(); <br />%&gt; <br />&lt;/body&gt; <br />&lt;/html&gt; </p><p><strong>七、jsp连接PostgreSQL数据库</strong> <br />testmysql.jsp如下： <br />&lt;%@ page contentType=&quot;text/html;charset=gb2312&quot;%&gt; <br />&lt;%@ page import=&quot;java.sql.*&quot;%&gt; <br />&lt;html&gt; <br />&lt;body&gt; <br />&lt;%Class.forName(&quot;org.postgresql.Driver&quot;).newInstance(); <br />String url =&quot;jdbc:postgresql://localhost/soft&quot; <br />//soft为你的数据库名 <br />String user=&quot;myuser&quot;; <br />String password=&quot;mypassword&quot;; <br />Connection conn= DriverManager.getConnection(url,user,password); <br />Statement stmt=conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE,ResultSet.CONCUR_UPDATABLE); <br />String sql=&quot;select * from test&quot;; <br />ResultSet rs=stmt.executeQuery(sql); <br />while(rs.next()) {%&gt; <br />您的第一个字段内容为：&lt;%=rs.getString(1)%&gt; <br />您的第二个字段内容为：&lt;%=rs.getString(2)%&gt; <br />&lt;%}%&gt; <br />&lt;%out.print(&quot;数据库操作成功，恭喜你&quot;);%&gt; <br />&lt;%rs.close(); <br />stmt.close(); <br />conn.close(); <br />%&gt; <br />&lt;/body&gt; <br />&lt;/html&gt;</p></div> 
					  </div> 
			    <p class="diaryFoot">- 作者： <a href="javascript:void(0);" onClick="window.open('http://publishblog.blogchina.com/blog/postMessage.b?receiver=413486','发送短消息','width=520, height=455')">youyou2005</a>  2005年07月8日, 星期五 17:16　
			    			    <a href="2207126.html#comment">回复（0）</a>
			     |　
			    <a href="2207126.html#trackback">引用（0）</a> 
			    <a href="javascript:void(keyit=window.open('http://blogmark.blogchina.com/jsp/key/quickaddkey.jsp?k='+encodeURI('JSP页面连接数据库大全')+'&u='+encodeURI('http://youyou2005.blogchina.com/youyou2005/2207126.html')+'&c='+encodeURI(''),'keyit','scrollbars=no,width=500,height=430,status=no,resizable=yes'));keyit.focus();">加入博采</a></td>          
			    </p>
			  </div>
						
		</div>
	 </div>
	<div id="footer"><a href="http://blog.blogchina.com/">Copyright&copy;2003-2004 BlogChina.COM All rights reserved </a></div>
  </div>
  <div id="extraDiv1"><span></span></div><div id="extraDiv2"><span></span></div><div id="extraDiv3"><span></span></div>
  <div id="extraDiv4"><span></span></div><div id="extraDiv5"><span></span></div><div id="extraDiv6"><span></span></div>
  
</body>
</html>
